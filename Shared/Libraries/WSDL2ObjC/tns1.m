#import "tns1.h"
#import <libxml/xmlstring.h>
#if TARGET_OS_IPHONE
#import <CFNetwork/CFNetwork.h>
#endif
tns1_statuscodes tns1_statuscodes_enumFromString(NSString *string)
{
	if([string isEqualToString:@"SUCCESS"]) {
		return tns1_statuscodes_SUCCESS;
	}
	if([string isEqualToString:@"FAIL"]) {
		return tns1_statuscodes_FAIL;
	}
	
	return tns1_statuscodes_none;
}
NSString * tns1_statuscodes_stringFromEnum(tns1_statuscodes enumValue)
{
	switch (enumValue) {
		case tns1_statuscodes_SUCCESS:
			return @"SUCCESS";
			break;
		case tns1_statuscodes_FAIL:
			return @"FAIL";
			break;
		default:
			return @"";
	}
}
tns1_ErrorType tns1_ErrorType_enumFromString(NSString *string)
{
	if([string isEqualToString:@"WARNING"]) {
		return tns1_ErrorType_WARNING;
	}
	if([string isEqualToString:@"ERROR"]) {
		return tns1_ErrorType_ERROR;
	}
	
	return tns1_ErrorType_none;
}
NSString * tns1_ErrorType_stringFromEnum(tns1_ErrorType enumValue)
{
	switch (enumValue) {
		case tns1_ErrorType_WARNING:
			return @"WARNING";
			break;
		case tns1_ErrorType_ERROR:
			return @"ERROR";
			break;
		default:
			return @"";
	}
}
@implementation tns1_DBSchemaErrorItem
- (id)init
{
	if((self = [super init])) {
		errorCode = 0;
		error = 0;
		type = 0;
		description = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(errorCode != nil) [errorCode release];
	if(error != nil) [error release];
	if(description != nil) [description release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.errorCode != 0) {
		xmlAddChild(node, [self.errorCode xmlNodeForDoc:node->doc elementName:@"errorCode" elementNSPrefix:nil]);
	}
	if(self.error != 0) {
		xmlAddChild(node, [self.error xmlNodeForDoc:node->doc elementName:@"error" elementNSPrefix:nil]);
	}
	if(self.type != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"type", [tns1_ErrorType_stringFromEnum(self.type) xmlString]);
	}
	if(self.description != 0) {
		xmlAddChild(node, [self.description xmlNodeForDoc:node->doc elementName:@"description" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize errorCode;
@synthesize error;
@synthesize type;
@synthesize description;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_DBSchemaErrorItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_DBSchemaErrorItem *newObject = [[tns1_DBSchemaErrorItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "errorCode")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.errorCode = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "error")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.error = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "type")) {
				
				tns1_ErrorType enumRepresentation = tns1_ErrorType_enumFromString(elementString);
				self.type = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "description")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.description = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_DBSchemaErrorList
- (id)init
{
	if((self = [super init])) {
		errorItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(errorItem != nil) [errorItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.errorItem != 0) {
		for(tns1_DBSchemaErrorItem * child in self.errorItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"errorItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize errorItem;
- (void)addErrorItem:(tns1_DBSchemaErrorItem *)toAdd
{
	if(toAdd != nil) [errorItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_DBSchemaErrorList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_DBSchemaErrorList *newObject = [[tns1_DBSchemaErrorList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "errorItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_DBSchemaErrorItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.errorItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_StatusHolder
- (id)init
{
	if((self = [super init])) {
		status = 0;
		statuscode = 0;
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statuscode != nil) [statuscode release];
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.status != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"status", [tns1_statuscodes_stringFromEnum(self.status) xmlString]);
	}
	if(self.statuscode != 0) {
		xmlAddChild(node, [self.statuscode xmlNodeForDoc:node->doc elementName:@"statuscode" elementNSPrefix:nil]);
	}
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize status;
@synthesize statuscode;
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_StatusHolder *)deserializeNode:(xmlNodePtr)cur
{
	tns1_StatusHolder *newObject = [[tns1_StatusHolder new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "status")) {
				
				tns1_statuscodes enumRepresentation = tns1_statuscodes_enumFromString(elementString);
				self.status = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statuscode")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statuscode = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ItemsCount
- (id)init
{
	if((self = [super init])) {
		Returned = 0;
		Found = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(Returned != nil) [Returned release];
	if(Found != nil) [Found release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.Returned != 0) {
		xmlAddChild(node, [self.Returned xmlNodeForDoc:node->doc elementName:@"Returned" elementNSPrefix:nil]);
	}
	if(self.Found != 0) {
		xmlAddChild(node, [self.Found xmlNodeForDoc:node->doc elementName:@"Found" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize Returned;
@synthesize Found;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ItemsCount *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ItemsCount *newObject = [[tns1_ItemsCount new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Returned")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Returned = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Found")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Found = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
tns1_ProfileTypes tns1_ProfileTypes_enumFromString(NSString *string)
{
	if([string isEqualToString:@"PARENT"]) {
		return tns1_ProfileTypes_PARENT;
	}
	if([string isEqualToString:@"CHILD"]) {
		return tns1_ProfileTypes_CHILD;
	}
	
	return tns1_ProfileTypes_none;
}
NSString * tns1_ProfileTypes_stringFromEnum(tns1_ProfileTypes enumValue)
{
	switch (enumValue) {
		case tns1_ProfileTypes_PARENT:
			return @"PARENT";
			break;
		case tns1_ProfileTypes_CHILD:
			return @"CHILD";
			break;
		default:
			return @"";
	}
}
tns1_BookshelfStyle tns1_BookshelfStyle_enumFromString(NSString *string)
{
	if([string isEqualToString:@"YOUNG_CHILD"]) {
		return tns1_BookshelfStyle_YOUNG_CHILD;
	}
	if([string isEqualToString:@"OLDER_CHILD"]) {
		return tns1_BookshelfStyle_OLDER_CHILD;
	}
	if([string isEqualToString:@"ADULT"]) {
		return tns1_BookshelfStyle_ADULT;
	}
	
	return tns1_BookshelfStyle_none;
}
NSString * tns1_BookshelfStyle_stringFromEnum(tns1_BookshelfStyle enumValue)
{
	switch (enumValue) {
		case tns1_BookshelfStyle_YOUNG_CHILD:
			return @"YOUNG_CHILD";
			break;
		case tns1_BookshelfStyle_OLDER_CHILD:
			return @"OLDER_CHILD";
			break;
		case tns1_BookshelfStyle_ADULT:
			return @"ADULT";
			break;
		default:
			return @"";
	}
}
tns1_ContentIdentifierTypes tns1_ContentIdentifierTypes_enumFromString(NSString *string)
{
	if([string isEqualToString:@"ISBN13"]) {
		return tns1_ContentIdentifierTypes_ISBN13;
	}
	
	return tns1_ContentIdentifierTypes_none;
}
NSString * tns1_ContentIdentifierTypes_stringFromEnum(tns1_ContentIdentifierTypes enumValue)
{
	switch (enumValue) {
		case tns1_ContentIdentifierTypes_ISBN13:
			return @"ISBN13";
			break;
		default:
			return @"";
	}
}
tns1_drmqualifiers tns1_drmqualifiers_enumFromString(NSString *string)
{
	if([string isEqualToString:@"FULL_WITH_DRM"]) {
		return tns1_drmqualifiers_FULL_WITH_DRM;
	}
	if([string isEqualToString:@"FULL_NO_DRM"]) {
		return tns1_drmqualifiers_FULL_NO_DRM;
	}
	if([string isEqualToString:@"SAMPLE"]) {
		return tns1_drmqualifiers_SAMPLE;
	}
	
	return tns1_drmqualifiers_none;
}
NSString * tns1_drmqualifiers_stringFromEnum(tns1_drmqualifiers enumValue)
{
	switch (enumValue) {
		case tns1_drmqualifiers_FULL_WITH_DRM:
			return @"FULL_WITH_DRM";
			break;
		case tns1_drmqualifiers_FULL_NO_DRM:
			return @"FULL_NO_DRM";
			break;
		case tns1_drmqualifiers_SAMPLE:
			return @"SAMPLE";
			break;
		default:
			return @"";
	}
}
@implementation tns1_ContentProfileItem
- (id)init
{
	if((self = [super init])) {
		profileID = 0;
		isFavorite = 0;
		rating = 0;
		lastPageLocation = 0;
		lastmodified = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(profileID != nil) [profileID release];
	if(isFavorite != nil) [isFavorite release];
	if(rating != nil) [rating release];
	if(lastPageLocation != nil) [lastPageLocation release];
	if(lastmodified != nil) [lastmodified release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.profileID != 0) {
		xmlAddChild(node, [self.profileID xmlNodeForDoc:node->doc elementName:@"profileID" elementNSPrefix:nil]);
	}
	if(self.isFavorite != 0) {
		xmlAddChild(node, [self.isFavorite xmlNodeForDoc:node->doc elementName:@"isFavorite" elementNSPrefix:nil]);
	}
	if(self.rating != 0) {
		xmlAddChild(node, [self.rating xmlNodeForDoc:node->doc elementName:@"rating" elementNSPrefix:nil]);
	}
	if(self.lastPageLocation != 0) {
		xmlAddChild(node, [self.lastPageLocation xmlNodeForDoc:node->doc elementName:@"lastPageLocation" elementNSPrefix:nil]);
	}
	if(self.lastmodified != 0) {
		xmlAddChild(node, [self.lastmodified xmlNodeForDoc:node->doc elementName:@"lastmodified" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize profileID;
@synthesize isFavorite;
@synthesize rating;
@synthesize lastPageLocation;
@synthesize lastmodified;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ContentProfileItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ContentProfileItem *newObject = [[tns1_ContentProfileItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileID")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.profileID = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "isFavorite")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.isFavorite = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "rating")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.rating = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lastPageLocation")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lastPageLocation = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lastmodified")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lastmodified = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ContentProfileList
- (id)init
{
	if((self = [super init])) {
		contentProfileItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(contentProfileItem != nil) [contentProfileItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.contentProfileItem != 0) {
		for(tns1_ContentProfileItem * child in self.contentProfileItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"contentProfileItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize contentProfileItem;
- (void)addContentProfileItem:(tns1_ContentProfileItem *)toAdd
{
	if(toAdd != nil) [contentProfileItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ContentProfileList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ContentProfileList *newObject = [[tns1_ContentProfileList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentProfileItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ContentProfileItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.contentProfileItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_CorpInfo
- (id)init
{
	if((self = [super init])) {
		transactionIdSourceField = 0;
		transactionId = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(transactionIdSourceField != nil) [transactionIdSourceField release];
	if(transactionId != nil) [transactionId release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.transactionIdSourceField != 0) {
		xmlAddChild(node, [self.transactionIdSourceField xmlNodeForDoc:node->doc elementName:@"transactionIdSourceField" elementNSPrefix:nil]);
	}
	if(self.transactionId != 0) {
		xmlAddChild(node, [self.transactionId xmlNodeForDoc:node->doc elementName:@"transactionId" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize transactionIdSourceField;
@synthesize transactionId;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_CorpInfo *)deserializeNode:(xmlNodePtr)cur
{
	tns1_CorpInfo *newObject = [[tns1_CorpInfo new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "transactionIdSourceField")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.transactionIdSourceField = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "transactionId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.transactionId = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_OrderSourceInfo
- (id)init
{
	if((self = [super init])) {
		srcSystem = 0;
		srcFile = 0;
		srcKey = 0;
		srcUserId = 0;
		srcHost = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(srcSystem != nil) [srcSystem release];
	if(srcFile != nil) [srcFile release];
	if(srcKey != nil) [srcKey release];
	if(srcUserId != nil) [srcUserId release];
	if(srcHost != nil) [srcHost release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.srcSystem != 0) {
		xmlAddChild(node, [self.srcSystem xmlNodeForDoc:node->doc elementName:@"srcSystem" elementNSPrefix:nil]);
	}
	if(self.srcFile != 0) {
		xmlAddChild(node, [self.srcFile xmlNodeForDoc:node->doc elementName:@"srcFile" elementNSPrefix:nil]);
	}
	if(self.srcKey != 0) {
		xmlAddChild(node, [self.srcKey xmlNodeForDoc:node->doc elementName:@"srcKey" elementNSPrefix:nil]);
	}
	if(self.srcUserId != 0) {
		xmlAddChild(node, [self.srcUserId xmlNodeForDoc:node->doc elementName:@"srcUserId" elementNSPrefix:nil]);
	}
	if(self.srcHost != 0) {
		xmlAddChild(node, [self.srcHost xmlNodeForDoc:node->doc elementName:@"srcHost" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize srcSystem;
@synthesize srcFile;
@synthesize srcKey;
@synthesize srcUserId;
@synthesize srcHost;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_OrderSourceInfo *)deserializeNode:(xmlNodePtr)cur
{
	tns1_OrderSourceInfo *newObject = [[tns1_OrderSourceInfo new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "srcSystem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.srcSystem = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "srcFile")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.srcFile = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "srcKey")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.srcKey = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "srcUserId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.srcUserId = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "srcHost")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.srcHost = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_OrderItem
- (id)init
{
	if((self = [super init])) {
		corpInfo = 0;
		orderSourceInfo = 0;
		orderIdSourceField = 0;
		orderId = 0;
		orderDate = 0;
		contentGroup = 0;
		childId = 0;
		teacherId = 0;
		refId3 = 0;
		refId4 = 0;
		refId5 = 0;
		transactionDate = 0;
		UCN = 0;
		quantity = 0;
		quantityInit = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(corpInfo != nil) [corpInfo release];
	if(orderSourceInfo != nil) [orderSourceInfo release];
	if(orderIdSourceField != nil) [orderIdSourceField release];
	if(orderId != nil) [orderId release];
	if(orderDate != nil) [orderDate release];
	if(contentGroup != nil) [contentGroup release];
	if(childId != nil) [childId release];
	if(teacherId != nil) [teacherId release];
	if(refId3 != nil) [refId3 release];
	if(refId4 != nil) [refId4 release];
	if(refId5 != nil) [refId5 release];
	if(transactionDate != nil) [transactionDate release];
	if(UCN != nil) [UCN release];
	if(quantity != nil) [quantity release];
	if(quantityInit != nil) [quantityInit release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.corpInfo != 0) {
		xmlAddChild(node, [self.corpInfo xmlNodeForDoc:node->doc elementName:@"corpInfo" elementNSPrefix:nil]);
	}
	if(self.orderSourceInfo != 0) {
		xmlAddChild(node, [self.orderSourceInfo xmlNodeForDoc:node->doc elementName:@"orderSourceInfo" elementNSPrefix:nil]);
	}
	if(self.orderIdSourceField != 0) {
		xmlAddChild(node, [self.orderIdSourceField xmlNodeForDoc:node->doc elementName:@"orderIdSourceField" elementNSPrefix:nil]);
	}
	if(self.orderId != 0) {
		xmlAddChild(node, [self.orderId xmlNodeForDoc:node->doc elementName:@"orderId" elementNSPrefix:nil]);
	}
	if(self.orderDate != 0) {
		xmlAddChild(node, [self.orderDate xmlNodeForDoc:node->doc elementName:@"orderDate" elementNSPrefix:nil]);
	}
	if(self.contentGroup != 0) {
		xmlAddChild(node, [self.contentGroup xmlNodeForDoc:node->doc elementName:@"contentGroup" elementNSPrefix:nil]);
	}
	if(self.childId != 0) {
		xmlAddChild(node, [self.childId xmlNodeForDoc:node->doc elementName:@"childId" elementNSPrefix:nil]);
	}
	if(self.teacherId != 0) {
		xmlAddChild(node, [self.teacherId xmlNodeForDoc:node->doc elementName:@"teacherId" elementNSPrefix:nil]);
	}
	if(self.refId3 != 0) {
		xmlAddChild(node, [self.refId3 xmlNodeForDoc:node->doc elementName:@"refId3" elementNSPrefix:nil]);
	}
	if(self.refId4 != 0) {
		xmlAddChild(node, [self.refId4 xmlNodeForDoc:node->doc elementName:@"refId4" elementNSPrefix:nil]);
	}
	if(self.refId5 != 0) {
		xmlAddChild(node, [self.refId5 xmlNodeForDoc:node->doc elementName:@"refId5" elementNSPrefix:nil]);
	}
	if(self.transactionDate != 0) {
		xmlAddChild(node, [self.transactionDate xmlNodeForDoc:node->doc elementName:@"transactionDate" elementNSPrefix:nil]);
	}
	if(self.UCN != 0) {
		xmlAddChild(node, [self.UCN xmlNodeForDoc:node->doc elementName:@"UCN" elementNSPrefix:nil]);
	}
	if(self.quantity != 0) {
		xmlAddChild(node, [self.quantity xmlNodeForDoc:node->doc elementName:@"quantity" elementNSPrefix:nil]);
	}
	if(self.quantityInit != 0) {
		xmlAddChild(node, [self.quantityInit xmlNodeForDoc:node->doc elementName:@"quantityInit" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize corpInfo;
@synthesize orderSourceInfo;
@synthesize orderIdSourceField;
@synthesize orderId;
@synthesize orderDate;
@synthesize contentGroup;
@synthesize childId;
@synthesize teacherId;
@synthesize refId3;
@synthesize refId4;
@synthesize refId5;
@synthesize transactionDate;
@synthesize UCN;
@synthesize quantity;
@synthesize quantityInit;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_OrderItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_OrderItem *newObject = [[tns1_OrderItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "corpInfo")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_CorpInfo class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.corpInfo = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "orderSourceInfo")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_OrderSourceInfo class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.orderSourceInfo = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "orderIdSourceField")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.orderIdSourceField = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "orderId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.orderId = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "orderDate")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.orderDate = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentGroup")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.contentGroup = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "childId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.childId = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "teacherId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.teacherId = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "refId3")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.refId3 = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "refId4")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.refId4 = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "refId5")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.refId5 = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "transactionDate")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.transactionDate = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "UCN")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.UCN = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "quantity")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.quantity = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "quantityInit")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.quantityInit = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_OrderList
- (id)init
{
	if((self = [super init])) {
		OrderItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(OrderItem != nil) [OrderItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.OrderItem != 0) {
		for(tns1_OrderItem * child in self.OrderItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"OrderItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize OrderItem;
- (void)addOrderItem:(tns1_OrderItem *)toAdd
{
	if(toAdd != nil) [OrderItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_OrderList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_OrderList *newObject = [[tns1_OrderList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "OrderItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_OrderItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.OrderItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_UserContentItem
- (id)init
{
	if((self = [super init])) {
		ContentIdentifier = 0;
		ContentIdentifierType = 0;
		DRMQualifier = 0;
		Format = 0;
		Version = 0;
		AverageRating = 0;
		numVotes = 0;
		ContentProfileForRatingsList = 0;
		OrderList = 0;
		lastmodified = 0;
		DefaultAssignment = 0;
		FreeBook = 0;
		LastVersion = 0;
		Quantity = 0;
		QuantityInit = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(ContentIdentifier != nil) [ContentIdentifier release];
	if(Format != nil) [Format release];
	if(Version != nil) [Version release];
	if(AverageRating != nil) [AverageRating release];
	if(numVotes != nil) [numVotes release];
	if(ContentProfileForRatingsList != nil) [ContentProfileForRatingsList release];
	if(OrderList != nil) [OrderList release];
	if(lastmodified != nil) [lastmodified release];
	if(DefaultAssignment != nil) [DefaultAssignment release];
	if(FreeBook != nil) [FreeBook release];
	if(LastVersion != nil) [LastVersion release];
	if(Quantity != nil) [Quantity release];
	if(QuantityInit != nil) [QuantityInit release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.ContentIdentifier != 0) {
		xmlAddChild(node, [self.ContentIdentifier xmlNodeForDoc:node->doc elementName:@"ContentIdentifier" elementNSPrefix:nil]);
	}
	if(self.ContentIdentifierType != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"ContentIdentifierType", [tns1_ContentIdentifierTypes_stringFromEnum(self.ContentIdentifierType) xmlString]);
	}
	if(self.DRMQualifier != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"DRMQualifier", [tns1_drmqualifiers_stringFromEnum(self.DRMQualifier) xmlString]);
	}
	if(self.Format != 0) {
		xmlAddChild(node, [self.Format xmlNodeForDoc:node->doc elementName:@"Format" elementNSPrefix:nil]);
	}
	if(self.Version != 0) {
		xmlAddChild(node, [self.Version xmlNodeForDoc:node->doc elementName:@"Version" elementNSPrefix:nil]);
	}
	if(self.AverageRating != 0) {
		xmlAddChild(node, [self.AverageRating xmlNodeForDoc:node->doc elementName:@"AverageRating" elementNSPrefix:nil]);
	}
	if(self.numVotes != 0) {
		xmlAddChild(node, [self.numVotes xmlNodeForDoc:node->doc elementName:@"numVotes" elementNSPrefix:nil]);
	}
	if(self.ContentProfileForRatingsList != 0) {
		xmlAddChild(node, [self.ContentProfileForRatingsList xmlNodeForDoc:node->doc elementName:@"ContentProfileForRatingsList" elementNSPrefix:nil]);
	}
	if(self.OrderList != 0) {
		xmlAddChild(node, [self.OrderList xmlNodeForDoc:node->doc elementName:@"OrderList" elementNSPrefix:nil]);
	}
	if(self.lastmodified != 0) {
		xmlAddChild(node, [self.lastmodified xmlNodeForDoc:node->doc elementName:@"lastmodified" elementNSPrefix:nil]);
	}
	if(self.DefaultAssignment != 0) {
		xmlAddChild(node, [self.DefaultAssignment xmlNodeForDoc:node->doc elementName:@"DefaultAssignment" elementNSPrefix:nil]);
	}
	if(self.FreeBook != 0) {
		xmlAddChild(node, [self.FreeBook xmlNodeForDoc:node->doc elementName:@"FreeBook" elementNSPrefix:nil]);
	}
	if(self.LastVersion != 0) {
		xmlAddChild(node, [self.LastVersion xmlNodeForDoc:node->doc elementName:@"LastVersion" elementNSPrefix:nil]);
	}
	if(self.Quantity != 0) {
		xmlAddChild(node, [self.Quantity xmlNodeForDoc:node->doc elementName:@"Quantity" elementNSPrefix:nil]);
	}
	if(self.QuantityInit != 0) {
		xmlAddChild(node, [self.QuantityInit xmlNodeForDoc:node->doc elementName:@"QuantityInit" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize ContentIdentifier;
@synthesize ContentIdentifierType;
@synthesize DRMQualifier;
@synthesize Format;
@synthesize Version;
@synthesize AverageRating;
@synthesize numVotes;
@synthesize ContentProfileForRatingsList;
@synthesize OrderList;
@synthesize lastmodified;
@synthesize DefaultAssignment;
@synthesize FreeBook;
@synthesize LastVersion;
@synthesize Quantity;
@synthesize QuantityInit;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_UserContentItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_UserContentItem *newObject = [[tns1_UserContentItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ContentIdentifier")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ContentIdentifier = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ContentIdentifierType")) {
				
				tns1_ContentIdentifierTypes enumRepresentation = tns1_ContentIdentifierTypes_enumFromString(elementString);
				self.ContentIdentifierType = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "DRMQualifier")) {
				
				tns1_drmqualifiers enumRepresentation = tns1_drmqualifiers_enumFromString(elementString);
				self.DRMQualifier = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Format")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Format = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Version")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Version = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AverageRating")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.AverageRating = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "numVotes")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.numVotes = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ContentProfileForRatingsList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ContentProfileList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ContentProfileForRatingsList = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "OrderList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_OrderList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.OrderList = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lastmodified")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lastmodified = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "DefaultAssignment")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.DefaultAssignment = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "FreeBook")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.FreeBook = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "LastVersion")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.LastVersion = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Quantity")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Quantity = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "QuantityInit")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.QuantityInit = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
tns1_TopFavoritesTypes tns1_TopFavoritesTypes_enumFromString(NSString *string)
{
	if([string isEqualToString:@"EREADER_CATEGORY"]) {
		return tns1_TopFavoritesTypes_EREADER_CATEGORY;
	}
	if([string isEqualToString:@"EREADER_CATEGORY_CLASS"]) {
		return tns1_TopFavoritesTypes_EREADER_CATEGORY_CLASS;
	}
	
	return tns1_TopFavoritesTypes_none;
}
NSString * tns1_TopFavoritesTypes_stringFromEnum(tns1_TopFavoritesTypes enumValue)
{
	switch (enumValue) {
		case tns1_TopFavoritesTypes_EREADER_CATEGORY:
			return @"EREADER_CATEGORY";
			break;
		case tns1_TopFavoritesTypes_EREADER_CATEGORY_CLASS:
			return @"EREADER_CATEGORY_CLASS";
			break;
		default:
			return @"";
	}
}
@implementation tns1_isbnItem
- (id)init
{
	if((self = [super init])) {
		ISBN = 0;
		Format = 0;
		IdentifierType = 0;
		Qualifier = 0;
		version = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(ISBN != nil) [ISBN release];
	if(Format != nil) [Format release];
	if(version != nil) [version release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.ISBN != 0) {
		xmlAddChild(node, [self.ISBN xmlNodeForDoc:node->doc elementName:@"ISBN" elementNSPrefix:nil]);
	}
	if(self.Format != 0) {
		xmlAddChild(node, [self.Format xmlNodeForDoc:node->doc elementName:@"Format" elementNSPrefix:nil]);
	}
	if(self.IdentifierType != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"IdentifierType", [tns1_ContentIdentifierTypes_stringFromEnum(self.IdentifierType) xmlString]);
	}
	if(self.Qualifier != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"Qualifier", [tns1_drmqualifiers_stringFromEnum(self.Qualifier) xmlString]);
	}
	if(self.version != 0) {
		xmlAddChild(node, [self.version xmlNodeForDoc:node->doc elementName:@"version" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize ISBN;
@synthesize Format;
@synthesize IdentifierType;
@synthesize Qualifier;
@synthesize version;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_isbnItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_isbnItem *newObject = [[tns1_isbnItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ISBN")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ISBN = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Format")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Format = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "IdentifierType")) {
				
				tns1_ContentIdentifierTypes enumRepresentation = tns1_ContentIdentifierTypes_enumFromString(elementString);
				self.IdentifierType = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Qualifier")) {
				
				tns1_drmqualifiers enumRepresentation = tns1_drmqualifiers_enumFromString(elementString);
				self.Qualifier = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "version")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.version = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ContentMetadataItem
- (id)init
{
	if((self = [super init])) {
		ContentIdentifier = 0;
		ContentIdentifierType = 0;
		AverageRating = 0;
		numVotes = 0;
		Title = 0;
		Author = 0;
		Description = 0;
		Version = 0;
		PageNumber = 0;
		FileSize = 0;
		DRMQualifier = 0;
		CoverURL = 0;
		ContentURL = 0;
		EreaderCategories = [[NSMutableArray alloc] init];
		Enhanced = 0;
		ThumbnailURL = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(ContentIdentifier != nil) [ContentIdentifier release];
	if(AverageRating != nil) [AverageRating release];
	if(numVotes != nil) [numVotes release];
	if(Title != nil) [Title release];
	if(Author != nil) [Author release];
	if(Description != nil) [Description release];
	if(Version != nil) [Version release];
	if(PageNumber != nil) [PageNumber release];
	if(FileSize != nil) [FileSize release];
	if(CoverURL != nil) [CoverURL release];
	if(ContentURL != nil) [ContentURL release];
	if(EreaderCategories != nil) [EreaderCategories release];
	if(Enhanced != nil) [Enhanced release];
	if(ThumbnailURL != nil) [ThumbnailURL release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.ContentIdentifier != 0) {
		xmlAddChild(node, [self.ContentIdentifier xmlNodeForDoc:node->doc elementName:@"ContentIdentifier" elementNSPrefix:nil]);
	}
	if(self.ContentIdentifierType != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"ContentIdentifierType", [tns1_ContentIdentifierTypes_stringFromEnum(self.ContentIdentifierType) xmlString]);
	}
	if(self.AverageRating != 0) {
		xmlAddChild(node, [self.AverageRating xmlNodeForDoc:node->doc elementName:@"AverageRating" elementNSPrefix:nil]);
	}
	if(self.numVotes != 0) {
		xmlAddChild(node, [self.numVotes xmlNodeForDoc:node->doc elementName:@"numVotes" elementNSPrefix:nil]);
	}
	if(self.Title != 0) {
		xmlAddChild(node, [self.Title xmlNodeForDoc:node->doc elementName:@"Title" elementNSPrefix:nil]);
	}
	if(self.Author != 0) {
		xmlAddChild(node, [self.Author xmlNodeForDoc:node->doc elementName:@"Author" elementNSPrefix:nil]);
	}
	if(self.Description != 0) {
		xmlAddChild(node, [self.Description xmlNodeForDoc:node->doc elementName:@"Description" elementNSPrefix:nil]);
	}
	if(self.Version != 0) {
		xmlAddChild(node, [self.Version xmlNodeForDoc:node->doc elementName:@"Version" elementNSPrefix:nil]);
	}
	if(self.PageNumber != 0) {
		xmlAddChild(node, [self.PageNumber xmlNodeForDoc:node->doc elementName:@"PageNumber" elementNSPrefix:nil]);
	}
	if(self.FileSize != 0) {
		xmlAddChild(node, [self.FileSize xmlNodeForDoc:node->doc elementName:@"FileSize" elementNSPrefix:nil]);
	}
	if(self.DRMQualifier != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"DRMQualifier", [tns1_drmqualifiers_stringFromEnum(self.DRMQualifier) xmlString]);
	}
	if(self.CoverURL != 0) {
		xmlAddChild(node, [self.CoverURL xmlNodeForDoc:node->doc elementName:@"CoverURL" elementNSPrefix:nil]);
	}
	if(self.ContentURL != 0) {
		xmlAddChild(node, [self.ContentURL xmlNodeForDoc:node->doc elementName:@"ContentURL" elementNSPrefix:nil]);
	}
	if(self.EreaderCategories != 0) {
		for(NSString * child in self.EreaderCategories) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"EreaderCategories" elementNSPrefix:nil]);
		}
	}
	if(self.Enhanced != 0) {
		xmlAddChild(node, [self.Enhanced xmlNodeForDoc:node->doc elementName:@"Enhanced" elementNSPrefix:nil]);
	}
	if(self.ThumbnailURL != 0) {
		xmlAddChild(node, [self.ThumbnailURL xmlNodeForDoc:node->doc elementName:@"ThumbnailURL" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize ContentIdentifier;
@synthesize ContentIdentifierType;
@synthesize AverageRating;
@synthesize numVotes;
@synthesize Title;
@synthesize Author;
@synthesize Description;
@synthesize Version;
@synthesize PageNumber;
@synthesize FileSize;
@synthesize DRMQualifier;
@synthesize CoverURL;
@synthesize ContentURL;
@synthesize EreaderCategories;
- (void)addEreaderCategories:(NSString *)toAdd
{
	if(toAdd != nil) [EreaderCategories addObject:toAdd];
}
@synthesize Enhanced;
@synthesize ThumbnailURL;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ContentMetadataItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ContentMetadataItem *newObject = [[tns1_ContentMetadataItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ContentIdentifier")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ContentIdentifier = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ContentIdentifierType")) {
				
				tns1_ContentIdentifierTypes enumRepresentation = tns1_ContentIdentifierTypes_enumFromString(elementString);
				self.ContentIdentifierType = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AverageRating")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.AverageRating = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "numVotes")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.numVotes = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Title")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Title = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Author")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Author = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Description")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Description = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Version")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Version = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "PageNumber")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.PageNumber = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "FileSize")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.FileSize = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "DRMQualifier")) {
				
				tns1_drmqualifiers enumRepresentation = tns1_drmqualifiers_enumFromString(elementString);
				self.DRMQualifier = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "CoverURL")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.CoverURL = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ContentURL")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ContentURL = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "EreaderCategories")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.EreaderCategories addObject:newChild];
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Enhanced")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Enhanced = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ThumbnailURL")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ThumbnailURL = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
tns1_SaveActions tns1_SaveActions_enumFromString(NSString *string)
{
	if([string isEqualToString:@"CREATE"]) {
		return tns1_SaveActions_CREATE;
	}
	if([string isEqualToString:@"UPDATE"]) {
		return tns1_SaveActions_UPDATE;
	}
	if([string isEqualToString:@"REMOVE"]) {
		return tns1_SaveActions_REMOVE;
	}
	
	return tns1_SaveActions_none;
}
NSString * tns1_SaveActions_stringFromEnum(tns1_SaveActions enumValue)
{
	switch (enumValue) {
		case tns1_SaveActions_CREATE:
			return @"CREATE";
			break;
		case tns1_SaveActions_UPDATE:
			return @"UPDATE";
			break;
		case tns1_SaveActions_REMOVE:
			return @"REMOVE";
			break;
		default:
			return @"";
	}
}
@implementation tns1_AssignedProfileItem
- (id)init
{
	if((self = [super init])) {
		profileID = 0;
		action = 0;
		lastmodified = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(profileID != nil) [profileID release];
	if(lastmodified != nil) [lastmodified release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.profileID != 0) {
		xmlAddChild(node, [self.profileID xmlNodeForDoc:node->doc elementName:@"profileID" elementNSPrefix:nil]);
	}
	if(self.action != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"action", [tns1_SaveActions_stringFromEnum(self.action) xmlString]);
	}
	if(self.lastmodified != 0) {
		xmlAddChild(node, [self.lastmodified xmlNodeForDoc:node->doc elementName:@"lastmodified" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize profileID;
@synthesize action;
@synthesize lastmodified;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AssignedProfileItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AssignedProfileItem *newObject = [[tns1_AssignedProfileItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileID")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.profileID = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "action")) {
				
				tns1_SaveActions enumRepresentation = tns1_SaveActions_enumFromString(elementString);
				self.action = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lastmodified")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lastmodified = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AssignedProfileList
- (id)init
{
	if((self = [super init])) {
		AssignedProfileItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(AssignedProfileItem != nil) [AssignedProfileItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.AssignedProfileItem != 0) {
		for(tns1_AssignedProfileItem * child in self.AssignedProfileItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"AssignedProfileItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize AssignedProfileItem;
- (void)addAssignedProfileItem:(tns1_AssignedProfileItem *)toAdd
{
	if(toAdd != nil) [AssignedProfileItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AssignedProfileList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AssignedProfileList *newObject = [[tns1_AssignedProfileList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AssignedProfileItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AssignedProfileItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.AssignedProfileItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ContentProfileAssignmentItem
- (id)init
{
	if((self = [super init])) {
		contentIdentifier = 0;
		ContentIdentifierType = 0;
		drmqualifier = 0;
		format = 0;
		AssignedProfileList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(contentIdentifier != nil) [contentIdentifier release];
	if(format != nil) [format release];
	if(AssignedProfileList != nil) [AssignedProfileList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.contentIdentifier != 0) {
		xmlAddChild(node, [self.contentIdentifier xmlNodeForDoc:node->doc elementName:@"contentIdentifier" elementNSPrefix:nil]);
	}
	if(self.ContentIdentifierType != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"ContentIdentifierType", [tns1_ContentIdentifierTypes_stringFromEnum(self.ContentIdentifierType) xmlString]);
	}
	if(self.drmqualifier != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"drmqualifier", [tns1_drmqualifiers_stringFromEnum(self.drmqualifier) xmlString]);
	}
	if(self.format != 0) {
		xmlAddChild(node, [self.format xmlNodeForDoc:node->doc elementName:@"format" elementNSPrefix:nil]);
	}
	if(self.AssignedProfileList != 0) {
		xmlAddChild(node, [self.AssignedProfileList xmlNodeForDoc:node->doc elementName:@"AssignedProfileList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize contentIdentifier;
@synthesize ContentIdentifierType;
@synthesize drmqualifier;
@synthesize format;
@synthesize AssignedProfileList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ContentProfileAssignmentItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ContentProfileAssignmentItem *newObject = [[tns1_ContentProfileAssignmentItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentIdentifier")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.contentIdentifier = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ContentIdentifierType")) {
				
				tns1_ContentIdentifierTypes enumRepresentation = tns1_ContentIdentifierTypes_enumFromString(elementString);
				self.ContentIdentifierType = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "drmqualifier")) {
				
				tns1_drmqualifiers enumRepresentation = tns1_drmqualifiers_enumFromString(elementString);
				self.drmqualifier = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "format")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.format = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AssignedProfileList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AssignedProfileList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.AssignedProfileList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ContentProfileAssignmentList
- (id)init
{
	if((self = [super init])) {
		ContentProfileAssignmentItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(ContentProfileAssignmentItem != nil) [ContentProfileAssignmentItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.ContentProfileAssignmentItem != 0) {
		for(tns1_ContentProfileAssignmentItem * child in self.ContentProfileAssignmentItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"ContentProfileAssignmentItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize ContentProfileAssignmentItem;
- (void)addContentProfileAssignmentItem:(tns1_ContentProfileAssignmentItem *)toAdd
{
	if(toAdd != nil) [ContentProfileAssignmentItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ContentProfileAssignmentList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ContentProfileAssignmentList *newObject = [[tns1_ContentProfileAssignmentList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ContentProfileAssignmentItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ContentProfileAssignmentItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.ContentProfileAssignmentItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_TopRatingsRequestItem
- (id)init
{
	if((self = [super init])) {
		TopRatingsType = 0;
		TopRatingsTypeValue = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(TopRatingsTypeValue != nil) [TopRatingsTypeValue release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.TopRatingsType != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"TopRatingsType", [tns1_TopFavoritesTypes_stringFromEnum(self.TopRatingsType) xmlString]);
	}
	if(self.TopRatingsTypeValue != 0) {
		xmlAddChild(node, [self.TopRatingsTypeValue xmlNodeForDoc:node->doc elementName:@"TopRatingsTypeValue" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize TopRatingsType;
@synthesize TopRatingsTypeValue;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_TopRatingsRequestItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_TopRatingsRequestItem *newObject = [[tns1_TopRatingsRequestItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "TopRatingsType")) {
				
				tns1_TopFavoritesTypes enumRepresentation = tns1_TopFavoritesTypes_enumFromString(elementString);
				self.TopRatingsType = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "TopRatingsTypeValue")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.TopRatingsTypeValue = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_TopRatingsRequestList
- (id)init
{
	if((self = [super init])) {
		TopRatingsRequestItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(TopRatingsRequestItem != nil) [TopRatingsRequestItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.TopRatingsRequestItem != 0) {
		for(tns1_TopRatingsRequestItem * child in self.TopRatingsRequestItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"TopRatingsRequestItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize TopRatingsRequestItem;
- (void)addTopRatingsRequestItem:(tns1_TopRatingsRequestItem *)toAdd
{
	if(toAdd != nil) [TopRatingsRequestItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_TopRatingsRequestList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_TopRatingsRequestList *newObject = [[tns1_TopRatingsRequestList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "TopRatingsRequestItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_TopRatingsRequestItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.TopRatingsRequestItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_TopRatingsContentItem
- (id)init
{
	if((self = [super init])) {
		ContentIdentifier = 0;
		ContentIdentifierType = 0;
		AverageRating = 0;
		numVotes = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(ContentIdentifier != nil) [ContentIdentifier release];
	if(AverageRating != nil) [AverageRating release];
	if(numVotes != nil) [numVotes release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.ContentIdentifier != 0) {
		xmlAddChild(node, [self.ContentIdentifier xmlNodeForDoc:node->doc elementName:@"ContentIdentifier" elementNSPrefix:nil]);
	}
	if(self.ContentIdentifierType != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"ContentIdentifierType", [tns1_ContentIdentifierTypes_stringFromEnum(self.ContentIdentifierType) xmlString]);
	}
	if(self.AverageRating != 0) {
		xmlAddChild(node, [self.AverageRating xmlNodeForDoc:node->doc elementName:@"AverageRating" elementNSPrefix:nil]);
	}
	if(self.numVotes != 0) {
		xmlAddChild(node, [self.numVotes xmlNodeForDoc:node->doc elementName:@"numVotes" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize ContentIdentifier;
@synthesize ContentIdentifierType;
@synthesize AverageRating;
@synthesize numVotes;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_TopRatingsContentItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_TopRatingsContentItem *newObject = [[tns1_TopRatingsContentItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ContentIdentifier")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ContentIdentifier = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ContentIdentifierType")) {
				
				tns1_ContentIdentifierTypes enumRepresentation = tns1_ContentIdentifierTypes_enumFromString(elementString);
				self.ContentIdentifierType = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AverageRating")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.AverageRating = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "numVotes")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.numVotes = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_TopRatingsContentItems
- (id)init
{
	if((self = [super init])) {
		TopRatingsContentItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(TopRatingsContentItem != nil) [TopRatingsContentItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.TopRatingsContentItem != 0) {
		for(tns1_TopRatingsContentItem * child in self.TopRatingsContentItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"TopRatingsContentItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize TopRatingsContentItem;
- (void)addTopRatingsContentItem:(tns1_TopRatingsContentItem *)toAdd
{
	if(toAdd != nil) [TopRatingsContentItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_TopRatingsContentItems *)deserializeNode:(xmlNodePtr)cur
{
	tns1_TopRatingsContentItems *newObject = [[tns1_TopRatingsContentItems new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "TopRatingsContentItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_TopRatingsContentItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.TopRatingsContentItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_TopRatingsResponseItem
- (id)init
{
	if((self = [super init])) {
		TopRatingsType = 0;
		TopRatingsTypeValue = 0;
		TopRatingsContentItems = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(TopRatingsTypeValue != nil) [TopRatingsTypeValue release];
	if(TopRatingsContentItems != nil) [TopRatingsContentItems release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.TopRatingsType != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"TopRatingsType", [tns1_TopFavoritesTypes_stringFromEnum(self.TopRatingsType) xmlString]);
	}
	if(self.TopRatingsTypeValue != 0) {
		xmlAddChild(node, [self.TopRatingsTypeValue xmlNodeForDoc:node->doc elementName:@"TopRatingsTypeValue" elementNSPrefix:nil]);
	}
	if(self.TopRatingsContentItems != 0) {
		xmlAddChild(node, [self.TopRatingsContentItems xmlNodeForDoc:node->doc elementName:@"TopRatingsContentItems" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize TopRatingsType;
@synthesize TopRatingsTypeValue;
@synthesize TopRatingsContentItems;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_TopRatingsResponseItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_TopRatingsResponseItem *newObject = [[tns1_TopRatingsResponseItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "TopRatingsType")) {
				
				tns1_TopFavoritesTypes enumRepresentation = tns1_TopFavoritesTypes_enumFromString(elementString);
				self.TopRatingsType = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "TopRatingsTypeValue")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.TopRatingsTypeValue = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "TopRatingsContentItems")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_TopRatingsContentItems class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.TopRatingsContentItems = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_TopRatingsResponseList
- (id)init
{
	if((self = [super init])) {
		TopRatingsResponseItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(TopRatingsResponseItem != nil) [TopRatingsResponseItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.TopRatingsResponseItem != 0) {
		for(tns1_TopRatingsResponseItem * child in self.TopRatingsResponseItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"TopRatingsResponseItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize TopRatingsResponseItem;
- (void)addTopRatingsResponseItem:(tns1_TopRatingsResponseItem *)toAdd
{
	if(toAdd != nil) [TopRatingsResponseItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_TopRatingsResponseList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_TopRatingsResponseList *newObject = [[tns1_TopRatingsResponseList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "TopRatingsResponseItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_TopRatingsResponseItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.TopRatingsResponseItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SaveProfileItem
- (id)init
{
	if((self = [super init])) {
		AutoAssignContentToProfiles = 0;
		ProfilePasswordRequired = 0;
		Firstname = 0;
		Lastname = 0;
		BirthDay = 0;
		LastModified = 0;
		screenname = 0;
		password = 0;
		userkey = 0;
		type = 0;
		id_ = 0;
		action = 0;
		BookshelfStyle = 0;
		storyInteractionEnabled = 0;
		recommendationsOn = 0;
		allowReadThrough = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(AutoAssignContentToProfiles != nil) [AutoAssignContentToProfiles release];
	if(ProfilePasswordRequired != nil) [ProfilePasswordRequired release];
	if(Firstname != nil) [Firstname release];
	if(Lastname != nil) [Lastname release];
	if(BirthDay != nil) [BirthDay release];
	if(LastModified != nil) [LastModified release];
	if(screenname != nil) [screenname release];
	if(password != nil) [password release];
	if(userkey != nil) [userkey release];
	if(id_ != nil) [id_ release];
	if(storyInteractionEnabled != nil) [storyInteractionEnabled release];
	if(recommendationsOn != nil) [recommendationsOn release];
	if(allowReadThrough != nil) [allowReadThrough release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.AutoAssignContentToProfiles != 0) {
		xmlAddChild(node, [self.AutoAssignContentToProfiles xmlNodeForDoc:node->doc elementName:@"AutoAssignContentToProfiles" elementNSPrefix:nil]);
	}
	if(self.ProfilePasswordRequired != 0) {
		xmlAddChild(node, [self.ProfilePasswordRequired xmlNodeForDoc:node->doc elementName:@"ProfilePasswordRequired" elementNSPrefix:nil]);
	}
	if(self.Firstname != 0) {
		xmlAddChild(node, [self.Firstname xmlNodeForDoc:node->doc elementName:@"Firstname" elementNSPrefix:nil]);
	}
	if(self.Lastname != 0) {
		xmlAddChild(node, [self.Lastname xmlNodeForDoc:node->doc elementName:@"Lastname" elementNSPrefix:nil]);
	}
	if(self.BirthDay != 0) {
		xmlAddChild(node, [self.BirthDay xmlNodeForDoc:node->doc elementName:@"BirthDay" elementNSPrefix:nil]);
	}
	if(self.LastModified != 0) {
		xmlAddChild(node, [self.LastModified xmlNodeForDoc:node->doc elementName:@"LastModified" elementNSPrefix:nil]);
	}
	if(self.screenname != 0) {
		xmlAddChild(node, [self.screenname xmlNodeForDoc:node->doc elementName:@"screenname" elementNSPrefix:nil]);
	}
	if(self.password != 0) {
		xmlAddChild(node, [self.password xmlNodeForDoc:node->doc elementName:@"password" elementNSPrefix:nil]);
	}
	if(self.userkey != 0) {
		xmlAddChild(node, [self.userkey xmlNodeForDoc:node->doc elementName:@"userkey" elementNSPrefix:nil]);
	}
	if(self.type != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"type", [tns1_ProfileTypes_stringFromEnum(self.type) xmlString]);
	}
	if(self.id_ != 0) {
		xmlAddChild(node, [self.id_ xmlNodeForDoc:node->doc elementName:@"id" elementNSPrefix:nil]);
	}
	if(self.action != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"action", [tns1_SaveActions_stringFromEnum(self.action) xmlString]);
	}
	if(self.BookshelfStyle != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"BookshelfStyle", [tns1_BookshelfStyle_stringFromEnum(self.BookshelfStyle) xmlString]);
	}
	if(self.storyInteractionEnabled != 0) {
		xmlAddChild(node, [self.storyInteractionEnabled xmlNodeForDoc:node->doc elementName:@"storyInteractionEnabled" elementNSPrefix:nil]);
	}
	if(self.recommendationsOn != 0) {
		xmlAddChild(node, [self.recommendationsOn xmlNodeForDoc:node->doc elementName:@"recommendationsOn" elementNSPrefix:nil]);
	}
	if(self.allowReadThrough != 0) {
		xmlAddChild(node, [self.allowReadThrough xmlNodeForDoc:node->doc elementName:@"allowReadThrough" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize AutoAssignContentToProfiles;
@synthesize ProfilePasswordRequired;
@synthesize Firstname;
@synthesize Lastname;
@synthesize BirthDay;
@synthesize LastModified;
@synthesize screenname;
@synthesize password;
@synthesize userkey;
@synthesize type;
@synthesize id_;
@synthesize action;
@synthesize BookshelfStyle;
@synthesize storyInteractionEnabled;
@synthesize recommendationsOn;
@synthesize allowReadThrough;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SaveProfileItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SaveProfileItem *newObject = [[tns1_SaveProfileItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AutoAssignContentToProfiles")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.AutoAssignContentToProfiles = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ProfilePasswordRequired")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ProfilePasswordRequired = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Firstname")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Firstname = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Lastname")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Lastname = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "BirthDay")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.BirthDay = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "LastModified")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.LastModified = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "screenname")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.screenname = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "password")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.password = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "userkey")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.userkey = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "type")) {
				
				tns1_ProfileTypes enumRepresentation = tns1_ProfileTypes_enumFromString(elementString);
				self.type = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "id")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.id_ = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "action")) {
				
				tns1_SaveActions enumRepresentation = tns1_SaveActions_enumFromString(elementString);
				self.action = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "BookshelfStyle")) {
				
				tns1_BookshelfStyle enumRepresentation = tns1_BookshelfStyle_enumFromString(elementString);
				self.BookshelfStyle = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "storyInteractionEnabled")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.storyInteractionEnabled = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "recommendationsOn")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.recommendationsOn = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "allowReadThrough")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.allowReadThrough = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SaveProfileList
- (id)init
{
	if((self = [super init])) {
		SaveProfileItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(SaveProfileItem != nil) [SaveProfileItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.SaveProfileItem != 0) {
		for(tns1_SaveProfileItem * child in self.SaveProfileItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"SaveProfileItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize SaveProfileItem;
- (void)addSaveProfileItem:(tns1_SaveProfileItem *)toAdd
{
	if(toAdd != nil) [SaveProfileItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SaveProfileList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SaveProfileList *newObject = [[tns1_SaveProfileList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "SaveProfileItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_SaveProfileItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.SaveProfileItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ProfileItem
- (id)init
{
	if((self = [super init])) {
		AutoAssignContentToProfiles = 0;
		ProfilePasswordRequired = 0;
		Firstname = 0;
		Lastname = 0;
		BirthDay = 0;
		screenname = 0;
		password = 0;
		userkey = 0;
		type = 0;
		id_ = 0;
		BookshelfStyle = 0;
		LastModified = 0;
		LastScreenNameModified = 0;
		LastPasswordModified = 0;
		storyInteractionEnabled = 0;
		recommendationsOn = 0;
		allowReadThrough = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(AutoAssignContentToProfiles != nil) [AutoAssignContentToProfiles release];
	if(ProfilePasswordRequired != nil) [ProfilePasswordRequired release];
	if(Firstname != nil) [Firstname release];
	if(Lastname != nil) [Lastname release];
	if(BirthDay != nil) [BirthDay release];
	if(screenname != nil) [screenname release];
	if(password != nil) [password release];
	if(userkey != nil) [userkey release];
	if(id_ != nil) [id_ release];
	if(LastModified != nil) [LastModified release];
	if(LastScreenNameModified != nil) [LastScreenNameModified release];
	if(LastPasswordModified != nil) [LastPasswordModified release];
	if(storyInteractionEnabled != nil) [storyInteractionEnabled release];
	if(recommendationsOn != nil) [recommendationsOn release];
	if(allowReadThrough != nil) [allowReadThrough release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.AutoAssignContentToProfiles != 0) {
		xmlAddChild(node, [self.AutoAssignContentToProfiles xmlNodeForDoc:node->doc elementName:@"AutoAssignContentToProfiles" elementNSPrefix:nil]);
	}
	if(self.ProfilePasswordRequired != 0) {
		xmlAddChild(node, [self.ProfilePasswordRequired xmlNodeForDoc:node->doc elementName:@"ProfilePasswordRequired" elementNSPrefix:nil]);
	}
	if(self.Firstname != 0) {
		xmlAddChild(node, [self.Firstname xmlNodeForDoc:node->doc elementName:@"Firstname" elementNSPrefix:nil]);
	}
	if(self.Lastname != 0) {
		xmlAddChild(node, [self.Lastname xmlNodeForDoc:node->doc elementName:@"Lastname" elementNSPrefix:nil]);
	}
	if(self.BirthDay != 0) {
		xmlAddChild(node, [self.BirthDay xmlNodeForDoc:node->doc elementName:@"BirthDay" elementNSPrefix:nil]);
	}
	if(self.screenname != 0) {
		xmlAddChild(node, [self.screenname xmlNodeForDoc:node->doc elementName:@"screenname" elementNSPrefix:nil]);
	}
	if(self.password != 0) {
		xmlAddChild(node, [self.password xmlNodeForDoc:node->doc elementName:@"password" elementNSPrefix:nil]);
	}
	if(self.userkey != 0) {
		xmlAddChild(node, [self.userkey xmlNodeForDoc:node->doc elementName:@"userkey" elementNSPrefix:nil]);
	}
	if(self.type != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"type", [tns1_ProfileTypes_stringFromEnum(self.type) xmlString]);
	}
	if(self.id_ != 0) {
		xmlAddChild(node, [self.id_ xmlNodeForDoc:node->doc elementName:@"id" elementNSPrefix:nil]);
	}
	if(self.BookshelfStyle != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"BookshelfStyle", [tns1_BookshelfStyle_stringFromEnum(self.BookshelfStyle) xmlString]);
	}
	if(self.LastModified != 0) {
		xmlAddChild(node, [self.LastModified xmlNodeForDoc:node->doc elementName:@"LastModified" elementNSPrefix:nil]);
	}
	if(self.LastScreenNameModified != 0) {
		xmlAddChild(node, [self.LastScreenNameModified xmlNodeForDoc:node->doc elementName:@"LastScreenNameModified" elementNSPrefix:nil]);
	}
	if(self.LastPasswordModified != 0) {
		xmlAddChild(node, [self.LastPasswordModified xmlNodeForDoc:node->doc elementName:@"LastPasswordModified" elementNSPrefix:nil]);
	}
	if(self.storyInteractionEnabled != 0) {
		xmlAddChild(node, [self.storyInteractionEnabled xmlNodeForDoc:node->doc elementName:@"storyInteractionEnabled" elementNSPrefix:nil]);
	}
	if(self.recommendationsOn != 0) {
		xmlAddChild(node, [self.recommendationsOn xmlNodeForDoc:node->doc elementName:@"recommendationsOn" elementNSPrefix:nil]);
	}
	if(self.allowReadThrough != 0) {
		xmlAddChild(node, [self.allowReadThrough xmlNodeForDoc:node->doc elementName:@"allowReadThrough" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize AutoAssignContentToProfiles;
@synthesize ProfilePasswordRequired;
@synthesize Firstname;
@synthesize Lastname;
@synthesize BirthDay;
@synthesize screenname;
@synthesize password;
@synthesize userkey;
@synthesize type;
@synthesize id_;
@synthesize BookshelfStyle;
@synthesize LastModified;
@synthesize LastScreenNameModified;
@synthesize LastPasswordModified;
@synthesize storyInteractionEnabled;
@synthesize recommendationsOn;
@synthesize allowReadThrough;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ProfileItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ProfileItem *newObject = [[tns1_ProfileItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AutoAssignContentToProfiles")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.AutoAssignContentToProfiles = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ProfilePasswordRequired")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ProfilePasswordRequired = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Firstname")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Firstname = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Lastname")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Lastname = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "BirthDay")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.BirthDay = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "screenname")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.screenname = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "password")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.password = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "userkey")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.userkey = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "type")) {
				
				tns1_ProfileTypes enumRepresentation = tns1_ProfileTypes_enumFromString(elementString);
				self.type = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "id")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.id_ = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "BookshelfStyle")) {
				
				tns1_BookshelfStyle enumRepresentation = tns1_BookshelfStyle_enumFromString(elementString);
				self.BookshelfStyle = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "LastModified")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.LastModified = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "LastScreenNameModified")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.LastScreenNameModified = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "LastPasswordModified")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.LastPasswordModified = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "storyInteractionEnabled")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.storyInteractionEnabled = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "recommendationsOn")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.recommendationsOn = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "allowReadThrough")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.allowReadThrough = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ProfileList
- (id)init
{
	if((self = [super init])) {
		ProfileItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(ProfileItem != nil) [ProfileItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.ProfileItem != 0) {
		for(tns1_ProfileItem * child in self.ProfileItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"ProfileItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize ProfileItem;
- (void)addProfileItem:(tns1_ProfileItem *)toAdd
{
	if(toAdd != nil) [ProfileItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ProfileList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ProfileList *newObject = [[tns1_ProfileList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ProfileItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ProfileItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.ProfileItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ProfileStatusItem
- (id)init
{
	if((self = [super init])) {
		id_ = 0;
		action = 0;
		status = 0;
		screenname = 0;
		statuscode = 0;
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(id_ != nil) [id_ release];
	if(screenname != nil) [screenname release];
	if(statuscode != nil) [statuscode release];
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.id_ != 0) {
		xmlAddChild(node, [self.id_ xmlNodeForDoc:node->doc elementName:@"id" elementNSPrefix:nil]);
	}
	if(self.action != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"action", [tns1_SaveActions_stringFromEnum(self.action) xmlString]);
	}
	if(self.status != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"status", [tns1_statuscodes_stringFromEnum(self.status) xmlString]);
	}
	if(self.screenname != 0) {
		xmlAddChild(node, [self.screenname xmlNodeForDoc:node->doc elementName:@"screenname" elementNSPrefix:nil]);
	}
	if(self.statuscode != 0) {
		xmlAddChild(node, [self.statuscode xmlNodeForDoc:node->doc elementName:@"statuscode" elementNSPrefix:nil]);
	}
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize id_;
@synthesize action;
@synthesize status;
@synthesize screenname;
@synthesize statuscode;
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ProfileStatusItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ProfileStatusItem *newObject = [[tns1_ProfileStatusItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "id")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.id_ = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "action")) {
				
				tns1_SaveActions enumRepresentation = tns1_SaveActions_enumFromString(elementString);
				self.action = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "status")) {
				
				tns1_statuscodes enumRepresentation = tns1_statuscodes_enumFromString(elementString);
				self.status = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "screenname")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.screenname = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statuscode")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statuscode = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ProfileStatusList
- (id)init
{
	if((self = [super init])) {
		ProfileStatusItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(ProfileStatusItem != nil) [ProfileStatusItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.ProfileStatusItem != 0) {
		for(tns1_ProfileStatusItem * child in self.ProfileStatusItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"ProfileStatusItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize ProfileStatusItem;
- (void)addProfileStatusItem:(tns1_ProfileStatusItem *)toAdd
{
	if(toAdd != nil) [ProfileStatusItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ProfileStatusList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ProfileStatusList *newObject = [[tns1_ProfileStatusList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ProfileStatusItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ProfileStatusItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.ProfileStatusItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_DeviceItem
- (id)init
{
	if((self = [super init])) {
		DeviceKey = 0;
		DeviceId = 0;
		AutoloadContent = 0;
		DevicePlatform = 0;
		DeviceNickname = 0;
		Active = 0;
		RemoveReason = 0;
		BadLoginAttempts = 0;
		BadLoginDatetimeUTC = 0;
		DeregistrationConfirmed = 0;
		lastmodified = 0;
		lastactivated = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(DeviceKey != nil) [DeviceKey release];
	if(DeviceId != nil) [DeviceId release];
	if(AutoloadContent != nil) [AutoloadContent release];
	if(DevicePlatform != nil) [DevicePlatform release];
	if(DeviceNickname != nil) [DeviceNickname release];
	if(Active != nil) [Active release];
	if(RemoveReason != nil) [RemoveReason release];
	if(BadLoginAttempts != nil) [BadLoginAttempts release];
	if(BadLoginDatetimeUTC != nil) [BadLoginDatetimeUTC release];
	if(DeregistrationConfirmed != nil) [DeregistrationConfirmed release];
	if(lastmodified != nil) [lastmodified release];
	if(lastactivated != nil) [lastactivated release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.DeviceKey != 0) {
		xmlAddChild(node, [self.DeviceKey xmlNodeForDoc:node->doc elementName:@"DeviceKey" elementNSPrefix:nil]);
	}
	if(self.DeviceId != 0) {
		xmlAddChild(node, [self.DeviceId xmlNodeForDoc:node->doc elementName:@"DeviceId" elementNSPrefix:nil]);
	}
	if(self.AutoloadContent != 0) {
		xmlAddChild(node, [self.AutoloadContent xmlNodeForDoc:node->doc elementName:@"AutoloadContent" elementNSPrefix:nil]);
	}
	if(self.DevicePlatform != 0) {
		xmlAddChild(node, [self.DevicePlatform xmlNodeForDoc:node->doc elementName:@"DevicePlatform" elementNSPrefix:nil]);
	}
	if(self.DeviceNickname != 0) {
		xmlAddChild(node, [self.DeviceNickname xmlNodeForDoc:node->doc elementName:@"DeviceNickname" elementNSPrefix:nil]);
	}
	if(self.Active != 0) {
		xmlAddChild(node, [self.Active xmlNodeForDoc:node->doc elementName:@"Active" elementNSPrefix:nil]);
	}
	if(self.RemoveReason != 0) {
		xmlAddChild(node, [self.RemoveReason xmlNodeForDoc:node->doc elementName:@"RemoveReason" elementNSPrefix:nil]);
	}
	if(self.BadLoginAttempts != 0) {
		xmlAddChild(node, [self.BadLoginAttempts xmlNodeForDoc:node->doc elementName:@"BadLoginAttempts" elementNSPrefix:nil]);
	}
	if(self.BadLoginDatetimeUTC != 0) {
		xmlAddChild(node, [self.BadLoginDatetimeUTC xmlNodeForDoc:node->doc elementName:@"BadLoginDatetimeUTC" elementNSPrefix:nil]);
	}
	if(self.DeregistrationConfirmed != 0) {
		xmlAddChild(node, [self.DeregistrationConfirmed xmlNodeForDoc:node->doc elementName:@"DeregistrationConfirmed" elementNSPrefix:nil]);
	}
	if(self.lastmodified != 0) {
		xmlAddChild(node, [self.lastmodified xmlNodeForDoc:node->doc elementName:@"lastmodified" elementNSPrefix:nil]);
	}
	if(self.lastactivated != 0) {
		xmlAddChild(node, [self.lastactivated xmlNodeForDoc:node->doc elementName:@"lastactivated" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize DeviceKey;
@synthesize DeviceId;
@synthesize AutoloadContent;
@synthesize DevicePlatform;
@synthesize DeviceNickname;
@synthesize Active;
@synthesize RemoveReason;
@synthesize BadLoginAttempts;
@synthesize BadLoginDatetimeUTC;
@synthesize DeregistrationConfirmed;
@synthesize lastmodified;
@synthesize lastactivated;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_DeviceItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_DeviceItem *newObject = [[tns1_DeviceItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "DeviceKey")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.DeviceKey = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "DeviceId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.DeviceId = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AutoloadContent")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.AutoloadContent = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "DevicePlatform")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.DevicePlatform = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "DeviceNickname")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.DeviceNickname = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Active")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Active = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "RemoveReason")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.RemoveReason = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "BadLoginAttempts")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.BadLoginAttempts = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "BadLoginDatetimeUTC")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.BadLoginDatetimeUTC = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "DeregistrationConfirmed")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.DeregistrationConfirmed = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lastmodified")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lastmodified = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lastactivated")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lastactivated = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_DeviceList
- (id)init
{
	if((self = [super init])) {
		DeviceItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(DeviceItem != nil) [DeviceItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.DeviceItem != 0) {
		for(tns1_DeviceItem * child in self.DeviceItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"DeviceItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize DeviceItem;
- (void)addDeviceItem:(tns1_DeviceItem *)toAdd
{
	if(toAdd != nil) [DeviceItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_DeviceList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_DeviceList *newObject = [[tns1_DeviceList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "DeviceItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_DeviceItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.DeviceItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_PrivateAnnotationsRequest
- (id)init
{
	if((self = [super init])) {
		version = 0;
		HighlightsAfter = 0;
		NotesAfter = 0;
		BookmarksAfter = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(version != nil) [version release];
	if(HighlightsAfter != nil) [HighlightsAfter release];
	if(NotesAfter != nil) [NotesAfter release];
	if(BookmarksAfter != nil) [BookmarksAfter release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.version != 0) {
		xmlAddChild(node, [self.version xmlNodeForDoc:node->doc elementName:@"version" elementNSPrefix:nil]);
	}
	if(self.HighlightsAfter != 0) {
		xmlAddChild(node, [self.HighlightsAfter xmlNodeForDoc:node->doc elementName:@"HighlightsAfter" elementNSPrefix:nil]);
	}
	if(self.NotesAfter != 0) {
		xmlAddChild(node, [self.NotesAfter xmlNodeForDoc:node->doc elementName:@"NotesAfter" elementNSPrefix:nil]);
	}
	if(self.BookmarksAfter != 0) {
		xmlAddChild(node, [self.BookmarksAfter xmlNodeForDoc:node->doc elementName:@"BookmarksAfter" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize version;
@synthesize HighlightsAfter;
@synthesize NotesAfter;
@synthesize BookmarksAfter;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_PrivateAnnotationsRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_PrivateAnnotationsRequest *newObject = [[tns1_PrivateAnnotationsRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "version")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.version = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "HighlightsAfter")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.HighlightsAfter = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "NotesAfter")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.NotesAfter = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "BookmarksAfter")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.BookmarksAfter = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AnnotationsRequestContentItem
- (id)init
{
	if((self = [super init])) {
		contentIdentifier = 0;
		ContentIdentifierType = 0;
		drmqualifier = 0;
		format = 0;
		PrivateAnnotationsRequest = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(contentIdentifier != nil) [contentIdentifier release];
	if(format != nil) [format release];
	if(PrivateAnnotationsRequest != nil) [PrivateAnnotationsRequest release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.contentIdentifier != 0) {
		xmlAddChild(node, [self.contentIdentifier xmlNodeForDoc:node->doc elementName:@"contentIdentifier" elementNSPrefix:nil]);
	}
	if(self.ContentIdentifierType != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"ContentIdentifierType", [tns1_ContentIdentifierTypes_stringFromEnum(self.ContentIdentifierType) xmlString]);
	}
	if(self.drmqualifier != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"drmqualifier", [tns1_drmqualifiers_stringFromEnum(self.drmqualifier) xmlString]);
	}
	if(self.format != 0) {
		xmlAddChild(node, [self.format xmlNodeForDoc:node->doc elementName:@"format" elementNSPrefix:nil]);
	}
	if(self.PrivateAnnotationsRequest != 0) {
		xmlAddChild(node, [self.PrivateAnnotationsRequest xmlNodeForDoc:node->doc elementName:@"PrivateAnnotationsRequest" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize contentIdentifier;
@synthesize ContentIdentifierType;
@synthesize drmqualifier;
@synthesize format;
@synthesize PrivateAnnotationsRequest;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AnnotationsRequestContentItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AnnotationsRequestContentItem *newObject = [[tns1_AnnotationsRequestContentItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentIdentifier")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.contentIdentifier = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ContentIdentifierType")) {
				
				tns1_ContentIdentifierTypes enumRepresentation = tns1_ContentIdentifierTypes_enumFromString(elementString);
				self.ContentIdentifierType = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "drmqualifier")) {
				
				tns1_drmqualifiers enumRepresentation = tns1_drmqualifiers_enumFromString(elementString);
				self.drmqualifier = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "format")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.format = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "PrivateAnnotationsRequest")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_PrivateAnnotationsRequest class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.PrivateAnnotationsRequest = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AnnotationsRequestContentList
- (id)init
{
	if((self = [super init])) {
		AnnotationsRequestContentItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(AnnotationsRequestContentItem != nil) [AnnotationsRequestContentItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.AnnotationsRequestContentItem != 0) {
		for(tns1_AnnotationsRequestContentItem * child in self.AnnotationsRequestContentItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"AnnotationsRequestContentItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize AnnotationsRequestContentItem;
- (void)addAnnotationsRequestContentItem:(tns1_AnnotationsRequestContentItem *)toAdd
{
	if(toAdd != nil) [AnnotationsRequestContentItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AnnotationsRequestContentList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AnnotationsRequestContentList *newObject = [[tns1_AnnotationsRequestContentList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AnnotationsRequestContentItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AnnotationsRequestContentItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.AnnotationsRequestContentItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AnnotationsRequestItem
- (id)init
{
	if((self = [super init])) {
		AnnotationsRequestContentList = 0;
		profileID = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(AnnotationsRequestContentList != nil) [AnnotationsRequestContentList release];
	if(profileID != nil) [profileID release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.AnnotationsRequestContentList != 0) {
		xmlAddChild(node, [self.AnnotationsRequestContentList xmlNodeForDoc:node->doc elementName:@"AnnotationsRequestContentList" elementNSPrefix:nil]);
	}
	if(self.profileID != 0) {
		xmlAddChild(node, [self.profileID xmlNodeForDoc:node->doc elementName:@"profileID" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize AnnotationsRequestContentList;
@synthesize profileID;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AnnotationsRequestItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AnnotationsRequestItem *newObject = [[tns1_AnnotationsRequestItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AnnotationsRequestContentList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AnnotationsRequestContentList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.AnnotationsRequestContentList = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileID")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.profileID = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AnnotationsRequestList
- (id)init
{
	if((self = [super init])) {
		AnnotationsRequestItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(AnnotationsRequestItem != nil) [AnnotationsRequestItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.AnnotationsRequestItem != 0) {
		for(tns1_AnnotationsRequestItem * child in self.AnnotationsRequestItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"AnnotationsRequestItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize AnnotationsRequestItem;
- (void)addAnnotationsRequestItem:(tns1_AnnotationsRequestItem *)toAdd
{
	if(toAdd != nil) [AnnotationsRequestItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AnnotationsRequestList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AnnotationsRequestList *newObject = [[tns1_AnnotationsRequestList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AnnotationsRequestItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AnnotationsRequestItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.AnnotationsRequestItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_WordIndex
- (id)init
{
	if((self = [super init])) {
		start = 0;
		end = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(start != nil) [start release];
	if(end != nil) [end release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.start != 0) {
		xmlAddChild(node, [self.start xmlNodeForDoc:node->doc elementName:@"start" elementNSPrefix:nil]);
	}
	if(self.end != 0) {
		xmlAddChild(node, [self.end xmlNodeForDoc:node->doc elementName:@"end" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize start;
@synthesize end;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_WordIndex *)deserializeNode:(xmlNodePtr)cur
{
	tns1_WordIndex *newObject = [[tns1_WordIndex new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "start")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.start = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "end")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.end = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_LocationText
- (id)init
{
	if((self = [super init])) {
		page = 0;
		wordindex = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(page != nil) [page release];
	if(wordindex != nil) [wordindex release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.page != 0) {
		xmlAddChild(node, [self.page xmlNodeForDoc:node->doc elementName:@"page" elementNSPrefix:nil]);
	}
	if(self.wordindex != 0) {
		xmlAddChild(node, [self.wordindex xmlNodeForDoc:node->doc elementName:@"wordindex" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize page;
@synthesize wordindex;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_LocationText *)deserializeNode:(xmlNodePtr)cur
{
	tns1_LocationText *newObject = [[tns1_LocationText new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "page")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.page = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "wordindex")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_WordIndex class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.wordindex = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_Highlight
- (id)init
{
	if((self = [super init])) {
		id_ = 0;
		action = 0;
		color = 0;
		location = 0;
		endPage = 0;
		version = 0;
		lastmodified = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(id_ != nil) [id_ release];
	if(color != nil) [color release];
	if(location != nil) [location release];
	if(endPage != nil) [endPage release];
	if(version != nil) [version release];
	if(lastmodified != nil) [lastmodified release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.id_ != 0) {
		xmlAddChild(node, [self.id_ xmlNodeForDoc:node->doc elementName:@"id" elementNSPrefix:nil]);
	}
	if(self.action != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"action", [tns1_SaveActions_stringFromEnum(self.action) xmlString]);
	}
	if(self.color != 0) {
		xmlAddChild(node, [self.color xmlNodeForDoc:node->doc elementName:@"color" elementNSPrefix:nil]);
	}
	if(self.location != 0) {
		xmlAddChild(node, [self.location xmlNodeForDoc:node->doc elementName:@"location" elementNSPrefix:nil]);
	}
	if(self.endPage != 0) {
		xmlAddChild(node, [self.endPage xmlNodeForDoc:node->doc elementName:@"endPage" elementNSPrefix:nil]);
	}
	if(self.version != 0) {
		xmlAddChild(node, [self.version xmlNodeForDoc:node->doc elementName:@"version" elementNSPrefix:nil]);
	}
	if(self.lastmodified != 0) {
		xmlAddChild(node, [self.lastmodified xmlNodeForDoc:node->doc elementName:@"lastmodified" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize id_;
@synthesize action;
@synthesize color;
@synthesize location;
@synthesize endPage;
@synthesize version;
@synthesize lastmodified;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_Highlight *)deserializeNode:(xmlNodePtr)cur
{
	tns1_Highlight *newObject = [[tns1_Highlight new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "id")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.id_ = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "action")) {
				
				tns1_SaveActions enumRepresentation = tns1_SaveActions_enumFromString(elementString);
				self.action = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "color")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.color = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "location")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_LocationText class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.location = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "endPage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.endPage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "version")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.version = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lastmodified")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lastmodified = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_Highlights
- (id)init
{
	if((self = [super init])) {
		Highlight = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(Highlight != nil) [Highlight release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.Highlight != 0) {
		for(tns1_Highlight * child in self.Highlight) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"Highlight" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize Highlight;
- (void)addHighlight:(tns1_Highlight *)toAdd
{
	if(toAdd != nil) [Highlight addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_Highlights *)deserializeNode:(xmlNodePtr)cur
{
	tns1_Highlights *newObject = [[tns1_Highlights new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Highlight")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_Highlight class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.Highlight addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_Coords
- (id)init
{
	if((self = [super init])) {
		x = 0;
		y = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(x != nil) [x release];
	if(y != nil) [y release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.x != 0) {
		xmlAddChild(node, [self.x xmlNodeForDoc:node->doc elementName:@"x" elementNSPrefix:nil]);
	}
	if(self.y != 0) {
		xmlAddChild(node, [self.y xmlNodeForDoc:node->doc elementName:@"y" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize x;
@synthesize y;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_Coords *)deserializeNode:(xmlNodePtr)cur
{
	tns1_Coords *newObject = [[tns1_Coords new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "x")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.x = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "y")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.y = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_LocationGraphics
- (id)init
{
	if((self = [super init])) {
		page = 0;
		coords = 0;
		wordindex = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(page != nil) [page release];
	if(coords != nil) [coords release];
	if(wordindex != nil) [wordindex release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.page != 0) {
		xmlAddChild(node, [self.page xmlNodeForDoc:node->doc elementName:@"page" elementNSPrefix:nil]);
	}
	if(self.coords != 0) {
		xmlAddChild(node, [self.coords xmlNodeForDoc:node->doc elementName:@"coords" elementNSPrefix:nil]);
	}
	if(self.wordindex != 0) {
		xmlAddChild(node, [self.wordindex xmlNodeForDoc:node->doc elementName:@"wordindex" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize page;
@synthesize coords;
@synthesize wordindex;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_LocationGraphics *)deserializeNode:(xmlNodePtr)cur
{
	tns1_LocationGraphics *newObject = [[tns1_LocationGraphics new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "page")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.page = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "coords")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_Coords class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.coords = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "wordindex")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.wordindex = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_Note
- (id)init
{
	if((self = [super init])) {
		id_ = 0;
		action = 0;
		location = 0;
		color = 0;
		value = 0;
		version = 0;
		lastmodified = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(id_ != nil) [id_ release];
	if(location != nil) [location release];
	if(color != nil) [color release];
	if(value != nil) [value release];
	if(version != nil) [version release];
	if(lastmodified != nil) [lastmodified release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.id_ != 0) {
		xmlAddChild(node, [self.id_ xmlNodeForDoc:node->doc elementName:@"id" elementNSPrefix:nil]);
	}
	if(self.action != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"action", [tns1_SaveActions_stringFromEnum(self.action) xmlString]);
	}
	if(self.location != 0) {
		xmlAddChild(node, [self.location xmlNodeForDoc:node->doc elementName:@"location" elementNSPrefix:nil]);
	}
	if(self.color != 0) {
		xmlAddChild(node, [self.color xmlNodeForDoc:node->doc elementName:@"color" elementNSPrefix:nil]);
	}
	if(self.value != 0) {
		xmlAddChild(node, [self.value xmlNodeForDoc:node->doc elementName:@"value" elementNSPrefix:nil]);
	}
	if(self.version != 0) {
		xmlAddChild(node, [self.version xmlNodeForDoc:node->doc elementName:@"version" elementNSPrefix:nil]);
	}
	if(self.lastmodified != 0) {
		xmlAddChild(node, [self.lastmodified xmlNodeForDoc:node->doc elementName:@"lastmodified" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize id_;
@synthesize action;
@synthesize location;
@synthesize color;
@synthesize value;
@synthesize version;
@synthesize lastmodified;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_Note *)deserializeNode:(xmlNodePtr)cur
{
	tns1_Note *newObject = [[tns1_Note new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "id")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.id_ = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "action")) {
				
				tns1_SaveActions enumRepresentation = tns1_SaveActions_enumFromString(elementString);
				self.action = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "location")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_LocationGraphics class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.location = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "color")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.color = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "value")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.value = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "version")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.version = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lastmodified")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lastmodified = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_Notes
- (id)init
{
	if((self = [super init])) {
		Note = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(Note != nil) [Note release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.Note != 0) {
		for(tns1_Note * child in self.Note) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"Note" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize Note;
- (void)addNote:(tns1_Note *)toAdd
{
	if(toAdd != nil) [Note addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_Notes *)deserializeNode:(xmlNodePtr)cur
{
	tns1_Notes *newObject = [[tns1_Notes new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Note")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_Note class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.Note addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_LocationBookmark
- (id)init
{
	if((self = [super init])) {
		page = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(page != nil) [page release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.page != 0) {
		xmlAddChild(node, [self.page xmlNodeForDoc:node->doc elementName:@"page" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize page;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_LocationBookmark *)deserializeNode:(xmlNodePtr)cur
{
	tns1_LocationBookmark *newObject = [[tns1_LocationBookmark new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "page")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.page = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_Bookmark
- (id)init
{
	if((self = [super init])) {
		id_ = 0;
		action = 0;
		text = 0;
		disabled = 0;
		location = 0;
		version = 0;
		lastmodified = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(id_ != nil) [id_ release];
	if(text != nil) [text release];
	if(disabled != nil) [disabled release];
	if(location != nil) [location release];
	if(version != nil) [version release];
	if(lastmodified != nil) [lastmodified release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.id_ != 0) {
		xmlAddChild(node, [self.id_ xmlNodeForDoc:node->doc elementName:@"id" elementNSPrefix:nil]);
	}
	if(self.action != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"action", [tns1_SaveActions_stringFromEnum(self.action) xmlString]);
	}
	if(self.text != 0) {
		xmlAddChild(node, [self.text xmlNodeForDoc:node->doc elementName:@"text" elementNSPrefix:nil]);
	}
	if(self.disabled != 0) {
		xmlAddChild(node, [self.disabled xmlNodeForDoc:node->doc elementName:@"disabled" elementNSPrefix:nil]);
	}
	if(self.location != 0) {
		xmlAddChild(node, [self.location xmlNodeForDoc:node->doc elementName:@"location" elementNSPrefix:nil]);
	}
	if(self.version != 0) {
		xmlAddChild(node, [self.version xmlNodeForDoc:node->doc elementName:@"version" elementNSPrefix:nil]);
	}
	if(self.lastmodified != 0) {
		xmlAddChild(node, [self.lastmodified xmlNodeForDoc:node->doc elementName:@"lastmodified" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize id_;
@synthesize action;
@synthesize text;
@synthesize disabled;
@synthesize location;
@synthesize version;
@synthesize lastmodified;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_Bookmark *)deserializeNode:(xmlNodePtr)cur
{
	tns1_Bookmark *newObject = [[tns1_Bookmark new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "id")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.id_ = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "action")) {
				
				tns1_SaveActions enumRepresentation = tns1_SaveActions_enumFromString(elementString);
				self.action = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "text")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.text = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "disabled")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.disabled = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "location")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_LocationBookmark class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.location = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "version")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.version = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lastmodified")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lastmodified = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_Bookmarks
- (id)init
{
	if((self = [super init])) {
		Bookmark = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(Bookmark != nil) [Bookmark release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.Bookmark != 0) {
		for(tns1_Bookmark * child in self.Bookmark) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"Bookmark" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize Bookmark;
- (void)addBookmark:(tns1_Bookmark *)toAdd
{
	if(toAdd != nil) [Bookmark addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_Bookmarks *)deserializeNode:(xmlNodePtr)cur
{
	tns1_Bookmarks *newObject = [[tns1_Bookmarks new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Bookmark")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_Bookmark class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.Bookmark addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_LastPage
- (id)init
{
	if((self = [super init])) {
		lastPageLocation = 0;
		percentage = 0;
		component = 0;
		lastmodified = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(lastPageLocation != nil) [lastPageLocation release];
	if(percentage != nil) [percentage release];
	if(component != nil) [component release];
	if(lastmodified != nil) [lastmodified release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.lastPageLocation != 0) {
		xmlAddChild(node, [self.lastPageLocation xmlNodeForDoc:node->doc elementName:@"lastPageLocation" elementNSPrefix:nil]);
	}
	if(self.percentage != 0) {
		xmlAddChild(node, [self.percentage xmlNodeForDoc:node->doc elementName:@"percentage" elementNSPrefix:nil]);
	}
	if(self.component != 0) {
		xmlAddChild(node, [self.component xmlNodeForDoc:node->doc elementName:@"component" elementNSPrefix:nil]);
	}
	if(self.lastmodified != 0) {
		xmlAddChild(node, [self.lastmodified xmlNodeForDoc:node->doc elementName:@"lastmodified" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize lastPageLocation;
@synthesize percentage;
@synthesize component;
@synthesize lastmodified;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_LastPage *)deserializeNode:(xmlNodePtr)cur
{
	tns1_LastPage *newObject = [[tns1_LastPage new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lastPageLocation")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lastPageLocation = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "percentage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.percentage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "component")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.component = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lastmodified")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lastmodified = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_Rating
- (id)init
{
	if((self = [super init])) {
		rating = 0;
		lastmodified = 0;
		averageRating = 0;
		numVotes = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(rating != nil) [rating release];
	if(lastmodified != nil) [lastmodified release];
	if(averageRating != nil) [averageRating release];
	if(numVotes != nil) [numVotes release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.rating != 0) {
		xmlAddChild(node, [self.rating xmlNodeForDoc:node->doc elementName:@"rating" elementNSPrefix:nil]);
	}
	if(self.lastmodified != 0) {
		xmlAddChild(node, [self.lastmodified xmlNodeForDoc:node->doc elementName:@"lastmodified" elementNSPrefix:nil]);
	}
	if(self.averageRating != 0) {
		xmlAddChild(node, [self.averageRating xmlNodeForDoc:node->doc elementName:@"averageRating" elementNSPrefix:nil]);
	}
	if(self.numVotes != 0) {
		xmlAddChild(node, [self.numVotes xmlNodeForDoc:node->doc elementName:@"numVotes" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize rating;
@synthesize lastmodified;
@synthesize averageRating;
@synthesize numVotes;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_Rating *)deserializeNode:(xmlNodePtr)cur
{
	tns1_Rating *newObject = [[tns1_Rating new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "rating")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.rating = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lastmodified")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lastmodified = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "averageRating")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.averageRating = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "numVotes")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.numVotes = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_PrivateAnnotations
- (id)init
{
	if((self = [super init])) {
		Highlights = 0;
		Notes = 0;
		Bookmarks = 0;
		LastPage = 0;
		Rating = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(Highlights != nil) [Highlights release];
	if(Notes != nil) [Notes release];
	if(Bookmarks != nil) [Bookmarks release];
	if(LastPage != nil) [LastPage release];
	if(Rating != nil) [Rating release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.Highlights != 0) {
		xmlAddChild(node, [self.Highlights xmlNodeForDoc:node->doc elementName:@"Highlights" elementNSPrefix:nil]);
	}
	if(self.Notes != 0) {
		xmlAddChild(node, [self.Notes xmlNodeForDoc:node->doc elementName:@"Notes" elementNSPrefix:nil]);
	}
	if(self.Bookmarks != 0) {
		xmlAddChild(node, [self.Bookmarks xmlNodeForDoc:node->doc elementName:@"Bookmarks" elementNSPrefix:nil]);
	}
	if(self.LastPage != 0) {
		xmlAddChild(node, [self.LastPage xmlNodeForDoc:node->doc elementName:@"LastPage" elementNSPrefix:nil]);
	}
	if(self.Rating != 0) {
		xmlAddChild(node, [self.Rating xmlNodeForDoc:node->doc elementName:@"Rating" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize Highlights;
@synthesize Notes;
@synthesize Bookmarks;
@synthesize LastPage;
@synthesize Rating;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_PrivateAnnotations *)deserializeNode:(xmlNodePtr)cur
{
	tns1_PrivateAnnotations *newObject = [[tns1_PrivateAnnotations new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Highlights")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_Highlights class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Highlights = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Notes")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_Notes class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Notes = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Bookmarks")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_Bookmarks class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Bookmarks = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "LastPage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_LastPage class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.LastPage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Rating")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_Rating class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Rating = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AnnotationsContentItem
- (id)init
{
	if((self = [super init])) {
		contentIdentifier = 0;
		ContentIdentifierType = 0;
		drmqualifier = 0;
		format = 0;
		PrivateAnnotations = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(contentIdentifier != nil) [contentIdentifier release];
	if(format != nil) [format release];
	if(PrivateAnnotations != nil) [PrivateAnnotations release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.contentIdentifier != 0) {
		xmlAddChild(node, [self.contentIdentifier xmlNodeForDoc:node->doc elementName:@"contentIdentifier" elementNSPrefix:nil]);
	}
	if(self.ContentIdentifierType != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"ContentIdentifierType", [tns1_ContentIdentifierTypes_stringFromEnum(self.ContentIdentifierType) xmlString]);
	}
	if(self.drmqualifier != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"drmqualifier", [tns1_drmqualifiers_stringFromEnum(self.drmqualifier) xmlString]);
	}
	if(self.format != 0) {
		xmlAddChild(node, [self.format xmlNodeForDoc:node->doc elementName:@"format" elementNSPrefix:nil]);
	}
	if(self.PrivateAnnotations != 0) {
		xmlAddChild(node, [self.PrivateAnnotations xmlNodeForDoc:node->doc elementName:@"PrivateAnnotations" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize contentIdentifier;
@synthesize ContentIdentifierType;
@synthesize drmqualifier;
@synthesize format;
@synthesize PrivateAnnotations;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AnnotationsContentItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AnnotationsContentItem *newObject = [[tns1_AnnotationsContentItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentIdentifier")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.contentIdentifier = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ContentIdentifierType")) {
				
				tns1_ContentIdentifierTypes enumRepresentation = tns1_ContentIdentifierTypes_enumFromString(elementString);
				self.ContentIdentifierType = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "drmqualifier")) {
				
				tns1_drmqualifiers enumRepresentation = tns1_drmqualifiers_enumFromString(elementString);
				self.drmqualifier = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "format")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.format = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "PrivateAnnotations")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_PrivateAnnotations class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.PrivateAnnotations = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AnnotationsContentList
- (id)init
{
	if((self = [super init])) {
		AnnotationsContentItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(AnnotationsContentItem != nil) [AnnotationsContentItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.AnnotationsContentItem != 0) {
		for(tns1_AnnotationsContentItem * child in self.AnnotationsContentItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"AnnotationsContentItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize AnnotationsContentItem;
- (void)addAnnotationsContentItem:(tns1_AnnotationsContentItem *)toAdd
{
	if(toAdd != nil) [AnnotationsContentItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AnnotationsContentList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AnnotationsContentList *newObject = [[tns1_AnnotationsContentList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AnnotationsContentItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AnnotationsContentItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.AnnotationsContentItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AnnotationsItem
- (id)init
{
	if((self = [super init])) {
		AnnotationsContentList = 0;
		profileID = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(AnnotationsContentList != nil) [AnnotationsContentList release];
	if(profileID != nil) [profileID release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.AnnotationsContentList != 0) {
		xmlAddChild(node, [self.AnnotationsContentList xmlNodeForDoc:node->doc elementName:@"AnnotationsContentList" elementNSPrefix:nil]);
	}
	if(self.profileID != 0) {
		xmlAddChild(node, [self.profileID xmlNodeForDoc:node->doc elementName:@"profileID" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize AnnotationsContentList;
@synthesize profileID;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AnnotationsItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AnnotationsItem *newObject = [[tns1_AnnotationsItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AnnotationsContentList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AnnotationsContentList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.AnnotationsContentList = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileID")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.profileID = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AnnotationsList
- (id)init
{
	if((self = [super init])) {
		AnnotationsItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(AnnotationsItem != nil) [AnnotationsItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.AnnotationsItem != 0) {
		for(tns1_AnnotationsItem * child in self.AnnotationsItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"AnnotationsItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize AnnotationsItem;
- (void)addAnnotationsItem:(tns1_AnnotationsItem *)toAdd
{
	if(toAdd != nil) [AnnotationsItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AnnotationsList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AnnotationsList *newObject = [[tns1_AnnotationsList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AnnotationsItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AnnotationsItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.AnnotationsItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_Favorite
- (id)init
{
	if((self = [super init])) {
		isFavorite = 0;
		lastmodified = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(isFavorite != nil) [isFavorite release];
	if(lastmodified != nil) [lastmodified release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.isFavorite != 0) {
		xmlAddChild(node, [self.isFavorite xmlNodeForDoc:node->doc elementName:@"isFavorite" elementNSPrefix:nil]);
	}
	if(self.lastmodified != 0) {
		xmlAddChild(node, [self.lastmodified xmlNodeForDoc:node->doc elementName:@"lastmodified" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize isFavorite;
@synthesize lastmodified;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_Favorite *)deserializeNode:(xmlNodePtr)cur
{
	tns1_Favorite *newObject = [[tns1_Favorite new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "isFavorite")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.isFavorite = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lastmodified")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lastmodified = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AnnotationTypeStatusItem
- (id)init
{
	if((self = [super init])) {
		id_ = 0;
		action = 0;
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(id_ != nil) [id_ release];
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.id_ != 0) {
		xmlAddChild(node, [self.id_ xmlNodeForDoc:node->doc elementName:@"id" elementNSPrefix:nil]);
	}
	if(self.action != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"action", [tns1_SaveActions_stringFromEnum(self.action) xmlString]);
	}
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize id_;
@synthesize action;
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AnnotationTypeStatusItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AnnotationTypeStatusItem *newObject = [[tns1_AnnotationTypeStatusItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "id")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.id_ = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "action")) {
				
				tns1_SaveActions enumRepresentation = tns1_SaveActions_enumFromString(elementString);
				self.action = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AnnotationTypeStatusList
- (id)init
{
	if((self = [super init])) {
		AnnotationTypeStatusItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(AnnotationTypeStatusItem != nil) [AnnotationTypeStatusItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.AnnotationTypeStatusItem != 0) {
		for(tns1_AnnotationTypeStatusItem * child in self.AnnotationTypeStatusItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"AnnotationTypeStatusItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize AnnotationTypeStatusItem;
- (void)addAnnotationTypeStatusItem:(tns1_AnnotationTypeStatusItem *)toAdd
{
	if(toAdd != nil) [AnnotationTypeStatusItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AnnotationTypeStatusList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AnnotationTypeStatusList *newObject = [[tns1_AnnotationTypeStatusList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AnnotationTypeStatusItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AnnotationTypeStatusItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.AnnotationTypeStatusItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_PrivateAnnotationsStatus
- (id)init
{
	if((self = [super init])) {
		HighlightsStatusList = 0;
		NotesStatusList = 0;
		BookmarksStatusList = 0;
		FavoriteStatus = 0;
		LastPageStatus = 0;
		RatingStatus = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(HighlightsStatusList != nil) [HighlightsStatusList release];
	if(NotesStatusList != nil) [NotesStatusList release];
	if(BookmarksStatusList != nil) [BookmarksStatusList release];
	if(FavoriteStatus != nil) [FavoriteStatus release];
	if(LastPageStatus != nil) [LastPageStatus release];
	if(RatingStatus != nil) [RatingStatus release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.HighlightsStatusList != 0) {
		xmlAddChild(node, [self.HighlightsStatusList xmlNodeForDoc:node->doc elementName:@"HighlightsStatusList" elementNSPrefix:nil]);
	}
	if(self.NotesStatusList != 0) {
		xmlAddChild(node, [self.NotesStatusList xmlNodeForDoc:node->doc elementName:@"NotesStatusList" elementNSPrefix:nil]);
	}
	if(self.BookmarksStatusList != 0) {
		xmlAddChild(node, [self.BookmarksStatusList xmlNodeForDoc:node->doc elementName:@"BookmarksStatusList" elementNSPrefix:nil]);
	}
	if(self.FavoriteStatus != 0) {
		xmlAddChild(node, [self.FavoriteStatus xmlNodeForDoc:node->doc elementName:@"FavoriteStatus" elementNSPrefix:nil]);
	}
	if(self.LastPageStatus != 0) {
		xmlAddChild(node, [self.LastPageStatus xmlNodeForDoc:node->doc elementName:@"LastPageStatus" elementNSPrefix:nil]);
	}
	if(self.RatingStatus != 0) {
		xmlAddChild(node, [self.RatingStatus xmlNodeForDoc:node->doc elementName:@"RatingStatus" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize HighlightsStatusList;
@synthesize NotesStatusList;
@synthesize BookmarksStatusList;
@synthesize FavoriteStatus;
@synthesize LastPageStatus;
@synthesize RatingStatus;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_PrivateAnnotationsStatus *)deserializeNode:(xmlNodePtr)cur
{
	tns1_PrivateAnnotationsStatus *newObject = [[tns1_PrivateAnnotationsStatus new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "HighlightsStatusList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AnnotationTypeStatusList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.HighlightsStatusList = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "NotesStatusList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AnnotationTypeStatusList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.NotesStatusList = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "BookmarksStatusList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AnnotationTypeStatusList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.BookmarksStatusList = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "FavoriteStatus")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AnnotationTypeStatusItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.FavoriteStatus = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "LastPageStatus")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AnnotationTypeStatusItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.LastPageStatus = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "RatingStatus")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AnnotationTypeStatusItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.RatingStatus = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AnnotationStatusContentItem
- (id)init
{
	if((self = [super init])) {
		contentIdentifier = 0;
		AverageRating = 0;
		numVotes = 0;
		statusmessage = 0;
		PrivateAnnotationsStatus = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(contentIdentifier != nil) [contentIdentifier release];
	if(AverageRating != nil) [AverageRating release];
	if(numVotes != nil) [numVotes release];
	if(statusmessage != nil) [statusmessage release];
	if(PrivateAnnotationsStatus != nil) [PrivateAnnotationsStatus release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.contentIdentifier != 0) {
		xmlAddChild(node, [self.contentIdentifier xmlNodeForDoc:node->doc elementName:@"contentIdentifier" elementNSPrefix:nil]);
	}
	if(self.AverageRating != 0) {
		xmlAddChild(node, [self.AverageRating xmlNodeForDoc:node->doc elementName:@"AverageRating" elementNSPrefix:nil]);
	}
	if(self.numVotes != 0) {
		xmlAddChild(node, [self.numVotes xmlNodeForDoc:node->doc elementName:@"numVotes" elementNSPrefix:nil]);
	}
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
	if(self.PrivateAnnotationsStatus != 0) {
		xmlAddChild(node, [self.PrivateAnnotationsStatus xmlNodeForDoc:node->doc elementName:@"PrivateAnnotationsStatus" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize contentIdentifier;
@synthesize AverageRating;
@synthesize numVotes;
@synthesize statusmessage;
@synthesize PrivateAnnotationsStatus;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AnnotationStatusContentItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AnnotationStatusContentItem *newObject = [[tns1_AnnotationStatusContentItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentIdentifier")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.contentIdentifier = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AverageRating")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.AverageRating = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "numVotes")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.numVotes = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "PrivateAnnotationsStatus")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_PrivateAnnotationsStatus class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.PrivateAnnotationsStatus = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AnnotationStatusContentList
- (id)init
{
	if((self = [super init])) {
		AnnotationStatusContentItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(AnnotationStatusContentItem != nil) [AnnotationStatusContentItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.AnnotationStatusContentItem != 0) {
		for(tns1_AnnotationStatusContentItem * child in self.AnnotationStatusContentItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"AnnotationStatusContentItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize AnnotationStatusContentItem;
- (void)addAnnotationStatusContentItem:(tns1_AnnotationStatusContentItem *)toAdd
{
	if(toAdd != nil) [AnnotationStatusContentItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AnnotationStatusContentList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AnnotationStatusContentList *newObject = [[tns1_AnnotationStatusContentList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AnnotationStatusContentItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AnnotationStatusContentItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.AnnotationStatusContentItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AnnotationStatusItem
- (id)init
{
	if((self = [super init])) {
		profileId = 0;
		statusmessage = 0;
		AnnotationStatusContentList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(profileId != nil) [profileId release];
	if(statusmessage != nil) [statusmessage release];
	if(AnnotationStatusContentList != nil) [AnnotationStatusContentList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.profileId != 0) {
		xmlAddChild(node, [self.profileId xmlNodeForDoc:node->doc elementName:@"profileId" elementNSPrefix:nil]);
	}
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
	if(self.AnnotationStatusContentList != 0) {
		xmlAddChild(node, [self.AnnotationStatusContentList xmlNodeForDoc:node->doc elementName:@"AnnotationStatusContentList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize profileId;
@synthesize statusmessage;
@synthesize AnnotationStatusContentList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AnnotationStatusItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AnnotationStatusItem *newObject = [[tns1_AnnotationStatusItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.profileId = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AnnotationStatusContentList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AnnotationStatusContentList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.AnnotationStatusContentList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AnnotationStatusList
- (id)init
{
	if((self = [super init])) {
		AnnotationStatusItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(AnnotationStatusItem != nil) [AnnotationStatusItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.AnnotationStatusItem != 0) {
		for(tns1_AnnotationStatusItem * child in self.AnnotationStatusItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"AnnotationStatusItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize AnnotationStatusItem;
- (void)addAnnotationStatusItem:(tns1_AnnotationStatusItem *)toAdd
{
	if(toAdd != nil) [AnnotationStatusItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AnnotationStatusList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AnnotationStatusList *newObject = [[tns1_AnnotationStatusList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AnnotationStatusItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AnnotationStatusItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.AnnotationStatusItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
tns1_aggregationPeriod tns1_aggregationPeriod_enumFromString(NSString *string)
{
	if([string isEqualToString:@"ALL"]) {
		return tns1_aggregationPeriod_ALL;
	}
	if([string isEqualToString:@"WEEK"]) {
		return tns1_aggregationPeriod_WEEK;
	}
	if([string isEqualToString:@"MONTH"]) {
		return tns1_aggregationPeriod_MONTH;
	}
	if([string isEqualToString:@"COMBINED"]) {
		return tns1_aggregationPeriod_COMBINED;
	}
	
	return tns1_aggregationPeriod_none;
}
NSString * tns1_aggregationPeriod_stringFromEnum(tns1_aggregationPeriod enumValue)
{
	switch (enumValue) {
		case tns1_aggregationPeriod_ALL:
			return @"ALL";
			break;
		case tns1_aggregationPeriod_WEEK:
			return @"WEEK";
			break;
		case tns1_aggregationPeriod_MONTH:
			return @"MONTH";
			break;
		case tns1_aggregationPeriod_COMBINED:
			return @"COMBINED";
			break;
		default:
			return @"";
	}
}
@implementation tns1_ReadingStatsAggregateItem
- (id)init
{
	if((self = [super init])) {
		pagesRead = 0;
		storyInteractions = 0;
		contentOpened = 0;
		dictionaryLookups = 0;
		readEvents = 0;
		readingDuration = 0;
		profileID = 0;
		period = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(pagesRead != nil) [pagesRead release];
	if(storyInteractions != nil) [storyInteractions release];
	if(contentOpened != nil) [contentOpened release];
	if(dictionaryLookups != nil) [dictionaryLookups release];
	if(readEvents != nil) [readEvents release];
	if(readingDuration != nil) [readingDuration release];
	if(profileID != nil) [profileID release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.pagesRead != 0) {
		xmlAddChild(node, [self.pagesRead xmlNodeForDoc:node->doc elementName:@"pagesRead" elementNSPrefix:nil]);
	}
	if(self.storyInteractions != 0) {
		xmlAddChild(node, [self.storyInteractions xmlNodeForDoc:node->doc elementName:@"storyInteractions" elementNSPrefix:nil]);
	}
	if(self.contentOpened != 0) {
		xmlAddChild(node, [self.contentOpened xmlNodeForDoc:node->doc elementName:@"contentOpened" elementNSPrefix:nil]);
	}
	if(self.dictionaryLookups != 0) {
		xmlAddChild(node, [self.dictionaryLookups xmlNodeForDoc:node->doc elementName:@"dictionaryLookups" elementNSPrefix:nil]);
	}
	if(self.readEvents != 0) {
		xmlAddChild(node, [self.readEvents xmlNodeForDoc:node->doc elementName:@"readEvents" elementNSPrefix:nil]);
	}
	if(self.readingDuration != 0) {
		xmlAddChild(node, [self.readingDuration xmlNodeForDoc:node->doc elementName:@"readingDuration" elementNSPrefix:nil]);
	}
	if(self.profileID != 0) {
		xmlAddChild(node, [self.profileID xmlNodeForDoc:node->doc elementName:@"profileID" elementNSPrefix:nil]);
	}
	if(self.period != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"period", [tns1_aggregationPeriod_stringFromEnum(self.period) xmlString]);
	}
}
/* elements */
@synthesize pagesRead;
@synthesize storyInteractions;
@synthesize contentOpened;
@synthesize dictionaryLookups;
@synthesize readEvents;
@synthesize readingDuration;
@synthesize profileID;
@synthesize period;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ReadingStatsAggregateItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ReadingStatsAggregateItem *newObject = [[tns1_ReadingStatsAggregateItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "pagesRead")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.pagesRead = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "storyInteractions")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.storyInteractions = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentOpened")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.contentOpened = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "dictionaryLookups")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.dictionaryLookups = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "readEvents")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.readEvents = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "readingDuration")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.readingDuration = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileID")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.profileID = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "period")) {
				
				tns1_aggregationPeriod enumRepresentation = tns1_aggregationPeriod_enumFromString(elementString);
				self.period = enumRepresentation;
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ReadingStatsAggregateList
- (id)init
{
	if((self = [super init])) {
		ReadingStatsAggregateItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(ReadingStatsAggregateItem != nil) [ReadingStatsAggregateItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.ReadingStatsAggregateItem != 0) {
		for(tns1_ReadingStatsAggregateItem * child in self.ReadingStatsAggregateItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"ReadingStatsAggregateItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize ReadingStatsAggregateItem;
- (void)addReadingStatsAggregateItem:(tns1_ReadingStatsAggregateItem *)toAdd
{
	if(toAdd != nil) [ReadingStatsAggregateItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ReadingStatsAggregateList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ReadingStatsAggregateList *newObject = [[tns1_ReadingStatsAggregateList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ReadingStatsAggregateItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ReadingStatsAggregateItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.ReadingStatsAggregateItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_DictionaryLookupsList
- (id)init
{
	if((self = [super init])) {
		dictionaryLookupsItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(dictionaryLookupsItem != nil) [dictionaryLookupsItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.dictionaryLookupsItem != 0) {
		for(NSString * child in self.dictionaryLookupsItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"dictionaryLookupsItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize dictionaryLookupsItem;
- (void)addDictionaryLookupsItem:(NSString *)toAdd
{
	if(toAdd != nil) [dictionaryLookupsItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_DictionaryLookupsList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_DictionaryLookupsList *newObject = [[tns1_DictionaryLookupsList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "dictionaryLookupsItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.dictionaryLookupsItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_QuizTrialsItem
- (id)init
{
	if((self = [super init])) {
		quizScore = 0;
		quizTotal = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(quizScore != nil) [quizScore release];
	if(quizTotal != nil) [quizTotal release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.quizScore != 0) {
		xmlAddChild(node, [self.quizScore xmlNodeForDoc:node->doc elementName:@"quizScore" elementNSPrefix:nil]);
	}
	if(self.quizTotal != 0) {
		xmlAddChild(node, [self.quizTotal xmlNodeForDoc:node->doc elementName:@"quizTotal" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize quizScore;
@synthesize quizTotal;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_QuizTrialsItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_QuizTrialsItem *newObject = [[tns1_QuizTrialsItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "quizScore")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.quizScore = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "quizTotal")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.quizTotal = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_QuizTrialsList
- (id)init
{
	if((self = [super init])) {
		quizTrialsItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(quizTrialsItem != nil) [quizTrialsItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.quizTrialsItem != 0) {
		for(tns1_QuizTrialsItem * child in self.quizTrialsItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"quizTrialsItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize quizTrialsItem;
- (void)addQuizTrialsItem:(tns1_QuizTrialsItem *)toAdd
{
	if(toAdd != nil) [quizTrialsItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_QuizTrialsList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_QuizTrialsList *newObject = [[tns1_QuizTrialsList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "quizTrialsItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_QuizTrialsItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.quizTrialsItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ReadingStatsEntryItem
- (id)init
{
	if((self = [super init])) {
		readingDuration = 0;
		pagesRead = 0;
		storyInteractions = 0;
		dictionaryLookups = 0;
		deviceKey = 0;
		timestamp = 0;
		DictionaryLookupsList = 0;
		quizResults = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(readingDuration != nil) [readingDuration release];
	if(pagesRead != nil) [pagesRead release];
	if(storyInteractions != nil) [storyInteractions release];
	if(dictionaryLookups != nil) [dictionaryLookups release];
	if(deviceKey != nil) [deviceKey release];
	if(timestamp != nil) [timestamp release];
	if(DictionaryLookupsList != nil) [DictionaryLookupsList release];
	if(quizResults != nil) [quizResults release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.readingDuration != 0) {
		xmlAddChild(node, [self.readingDuration xmlNodeForDoc:node->doc elementName:@"readingDuration" elementNSPrefix:nil]);
	}
	if(self.pagesRead != 0) {
		xmlAddChild(node, [self.pagesRead xmlNodeForDoc:node->doc elementName:@"pagesRead" elementNSPrefix:nil]);
	}
	if(self.storyInteractions != 0) {
		xmlAddChild(node, [self.storyInteractions xmlNodeForDoc:node->doc elementName:@"storyInteractions" elementNSPrefix:nil]);
	}
	if(self.dictionaryLookups != 0) {
		xmlAddChild(node, [self.dictionaryLookups xmlNodeForDoc:node->doc elementName:@"dictionaryLookups" elementNSPrefix:nil]);
	}
	if(self.deviceKey != 0) {
		xmlAddChild(node, [self.deviceKey xmlNodeForDoc:node->doc elementName:@"deviceKey" elementNSPrefix:nil]);
	}
	if(self.timestamp != 0) {
		xmlAddChild(node, [self.timestamp xmlNodeForDoc:node->doc elementName:@"timestamp" elementNSPrefix:nil]);
	}
	if(self.DictionaryLookupsList != 0) {
		xmlAddChild(node, [self.DictionaryLookupsList xmlNodeForDoc:node->doc elementName:@"DictionaryLookupsList" elementNSPrefix:nil]);
	}
	if(self.quizResults != 0) {
		xmlAddChild(node, [self.quizResults xmlNodeForDoc:node->doc elementName:@"quizResults" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize readingDuration;
@synthesize pagesRead;
@synthesize storyInteractions;
@synthesize dictionaryLookups;
@synthesize deviceKey;
@synthesize timestamp;
@synthesize DictionaryLookupsList;
@synthesize quizResults;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ReadingStatsEntryItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ReadingStatsEntryItem *newObject = [[tns1_ReadingStatsEntryItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "readingDuration")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.readingDuration = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "pagesRead")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.pagesRead = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "storyInteractions")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.storyInteractions = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "dictionaryLookups")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.dictionaryLookups = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "deviceKey")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.deviceKey = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "timestamp")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.timestamp = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "DictionaryLookupsList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_DictionaryLookupsList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.DictionaryLookupsList = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "quizResults")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_QuizTrialsList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.quizResults = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ReadingStatsEntryList
- (id)init
{
	if((self = [super init])) {
		ReadingStatsEntryItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(ReadingStatsEntryItem != nil) [ReadingStatsEntryItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.ReadingStatsEntryItem != 0) {
		for(tns1_ReadingStatsEntryItem * child in self.ReadingStatsEntryItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"ReadingStatsEntryItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize ReadingStatsEntryItem;
- (void)addReadingStatsEntryItem:(tns1_ReadingStatsEntryItem *)toAdd
{
	if(toAdd != nil) [ReadingStatsEntryItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ReadingStatsEntryList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ReadingStatsEntryList *newObject = [[tns1_ReadingStatsEntryList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ReadingStatsEntryItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ReadingStatsEntryItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.ReadingStatsEntryItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ReadingStatsContentItem
- (id)init
{
	if((self = [super init])) {
		ContentIdentifierType = 0;
		contentIdentifier = 0;
		drmqualifier = 0;
		format = 0;
		ReadingStatsEntryList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(contentIdentifier != nil) [contentIdentifier release];
	if(format != nil) [format release];
	if(ReadingStatsEntryList != nil) [ReadingStatsEntryList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.ContentIdentifierType != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"ContentIdentifierType", [tns1_ContentIdentifierTypes_stringFromEnum(self.ContentIdentifierType) xmlString]);
	}
	if(self.contentIdentifier != 0) {
		xmlAddChild(node, [self.contentIdentifier xmlNodeForDoc:node->doc elementName:@"contentIdentifier" elementNSPrefix:nil]);
	}
	if(self.drmqualifier != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"drmqualifier", [tns1_drmqualifiers_stringFromEnum(self.drmqualifier) xmlString]);
	}
	if(self.format != 0) {
		xmlAddChild(node, [self.format xmlNodeForDoc:node->doc elementName:@"format" elementNSPrefix:nil]);
	}
	if(self.ReadingStatsEntryList != 0) {
		xmlAddChild(node, [self.ReadingStatsEntryList xmlNodeForDoc:node->doc elementName:@"ReadingStatsEntryList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize ContentIdentifierType;
@synthesize contentIdentifier;
@synthesize drmqualifier;
@synthesize format;
@synthesize ReadingStatsEntryList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ReadingStatsContentItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ReadingStatsContentItem *newObject = [[tns1_ReadingStatsContentItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ContentIdentifierType")) {
				
				tns1_ContentIdentifierTypes enumRepresentation = tns1_ContentIdentifierTypes_enumFromString(elementString);
				self.ContentIdentifierType = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentIdentifier")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.contentIdentifier = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "drmqualifier")) {
				
				tns1_drmqualifiers enumRepresentation = tns1_drmqualifiers_enumFromString(elementString);
				self.drmqualifier = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "format")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.format = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ReadingStatsEntryList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ReadingStatsEntryList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ReadingStatsEntryList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ReadingStatsContentList
- (id)init
{
	if((self = [super init])) {
		ReadingStatsContentItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(ReadingStatsContentItem != nil) [ReadingStatsContentItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.ReadingStatsContentItem != 0) {
		for(tns1_ReadingStatsContentItem * child in self.ReadingStatsContentItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"ReadingStatsContentItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize ReadingStatsContentItem;
- (void)addReadingStatsContentItem:(tns1_ReadingStatsContentItem *)toAdd
{
	if(toAdd != nil) [ReadingStatsContentItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ReadingStatsContentList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ReadingStatsContentList *newObject = [[tns1_ReadingStatsContentList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ReadingStatsContentItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ReadingStatsContentItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.ReadingStatsContentItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ReadingStatsDetailItem
- (id)init
{
	if((self = [super init])) {
		ReadingStatsContentList = 0;
		profileID = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(ReadingStatsContentList != nil) [ReadingStatsContentList release];
	if(profileID != nil) [profileID release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.ReadingStatsContentList != 0) {
		xmlAddChild(node, [self.ReadingStatsContentList xmlNodeForDoc:node->doc elementName:@"ReadingStatsContentList" elementNSPrefix:nil]);
	}
	if(self.profileID != 0) {
		xmlAddChild(node, [self.profileID xmlNodeForDoc:node->doc elementName:@"profileID" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize ReadingStatsContentList;
@synthesize profileID;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ReadingStatsDetailItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ReadingStatsDetailItem *newObject = [[tns1_ReadingStatsDetailItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ReadingStatsContentList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ReadingStatsContentList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ReadingStatsContentList = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileID")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.profileID = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ReadingStatsDetailList
- (id)init
{
	if((self = [super init])) {
		ReadingStatsDetailItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(ReadingStatsDetailItem != nil) [ReadingStatsDetailItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.ReadingStatsDetailItem != 0) {
		for(tns1_ReadingStatsDetailItem * child in self.ReadingStatsDetailItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"ReadingStatsDetailItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize ReadingStatsDetailItem;
- (void)addReadingStatsDetailItem:(tns1_ReadingStatsDetailItem *)toAdd
{
	if(toAdd != nil) [ReadingStatsDetailItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ReadingStatsDetailList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ReadingStatsDetailList *newObject = [[tns1_ReadingStatsDetailList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ReadingStatsDetailItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ReadingStatsDetailItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.ReadingStatsDetailItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_LookupWordList
- (id)init
{
	if((self = [super init])) {
		lookupWordItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(lookupWordItem != nil) [lookupWordItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.lookupWordItem != 0) {
		for(NSString * child in self.lookupWordItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"lookupWordItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize lookupWordItem;
- (void)addLookupWordItem:(NSString *)toAdd
{
	if(toAdd != nil) [lookupWordItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_LookupWordList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_LookupWordList *newObject = [[tns1_LookupWordList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lookupWordItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.lookupWordItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_MonthlyAverageItem
- (id)init
{
	if((self = [super init])) {
		month = 0;
		year = 0;
		guidedReadingLevel = 0;
		eBooksCompleted = 0;
		readingDuration = 0;
		eBookLexileLevel = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(month != nil) [month release];
	if(year != nil) [year release];
	if(guidedReadingLevel != nil) [guidedReadingLevel release];
	if(eBooksCompleted != nil) [eBooksCompleted release];
	if(readingDuration != nil) [readingDuration release];
	if(eBookLexileLevel != nil) [eBookLexileLevel release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.month != 0) {
		xmlAddChild(node, [self.month xmlNodeForDoc:node->doc elementName:@"month" elementNSPrefix:nil]);
	}
	if(self.year != 0) {
		xmlAddChild(node, [self.year xmlNodeForDoc:node->doc elementName:@"year" elementNSPrefix:nil]);
	}
	if(self.guidedReadingLevel != 0) {
		xmlAddChild(node, [self.guidedReadingLevel xmlNodeForDoc:node->doc elementName:@"guidedReadingLevel" elementNSPrefix:nil]);
	}
	if(self.eBooksCompleted != 0) {
		xmlAddChild(node, [self.eBooksCompleted xmlNodeForDoc:node->doc elementName:@"eBooksCompleted" elementNSPrefix:nil]);
	}
	if(self.readingDuration != 0) {
		xmlAddChild(node, [self.readingDuration xmlNodeForDoc:node->doc elementName:@"readingDuration" elementNSPrefix:nil]);
	}
	if(self.eBookLexileLevel != 0) {
		xmlAddChild(node, [self.eBookLexileLevel xmlNodeForDoc:node->doc elementName:@"eBookLexileLevel" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize month;
@synthesize year;
@synthesize guidedReadingLevel;
@synthesize eBooksCompleted;
@synthesize readingDuration;
@synthesize eBookLexileLevel;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_MonthlyAverageItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_MonthlyAverageItem *newObject = [[tns1_MonthlyAverageItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "month")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.month = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "year")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.year = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "guidedReadingLevel")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.guidedReadingLevel = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "eBooksCompleted")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.eBooksCompleted = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "readingDuration")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.readingDuration = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "eBookLexileLevel")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.eBookLexileLevel = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_MonthlyAverageList
- (id)init
{
	if((self = [super init])) {
		monthlyAverageItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(monthlyAverageItem != nil) [monthlyAverageItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.monthlyAverageItem != 0) {
		for(tns1_MonthlyAverageItem * child in self.monthlyAverageItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"monthlyAverageItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize monthlyAverageItem;
- (void)addMonthlyAverageItem:(tns1_MonthlyAverageItem *)toAdd
{
	if(toAdd != nil) [monthlyAverageItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_MonthlyAverageList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_MonthlyAverageList *newObject = [[tns1_MonthlyAverageList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "monthlyAverageItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_MonthlyAverageItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.monthlyAverageItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_MonthlyAverageProfileItem
- (id)init
{
	if((self = [super init])) {
		profileID = 0;
		monthlyAverageList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(profileID != nil) [profileID release];
	if(monthlyAverageList != nil) [monthlyAverageList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.profileID != 0) {
		xmlAddChild(node, [self.profileID xmlNodeForDoc:node->doc elementName:@"profileID" elementNSPrefix:nil]);
	}
	if(self.monthlyAverageList != 0) {
		xmlAddChild(node, [self.monthlyAverageList xmlNodeForDoc:node->doc elementName:@"monthlyAverageList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize profileID;
@synthesize monthlyAverageList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_MonthlyAverageProfileItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_MonthlyAverageProfileItem *newObject = [[tns1_MonthlyAverageProfileItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileID")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.profileID = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "monthlyAverageList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_MonthlyAverageList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.monthlyAverageList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_MonthlyAverageProfileList
- (id)init
{
	if((self = [super init])) {
		monthlyAverageProfileItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(monthlyAverageProfileItem != nil) [monthlyAverageProfileItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.monthlyAverageProfileItem != 0) {
		for(tns1_MonthlyAverageProfileItem * child in self.monthlyAverageProfileItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"monthlyAverageProfileItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize monthlyAverageProfileItem;
- (void)addMonthlyAverageProfileItem:(tns1_MonthlyAverageProfileItem *)toAdd
{
	if(toAdd != nil) [monthlyAverageProfileItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_MonthlyAverageProfileList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_MonthlyAverageProfileList *newObject = [[tns1_MonthlyAverageProfileList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "monthlyAverageProfileItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_MonthlyAverageProfileItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.monthlyAverageProfileItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_BookIdentifier
- (id)init
{
	if((self = [super init])) {
		contentIdentifier = 0;
		contentIdentifierType = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(contentIdentifier != nil) [contentIdentifier release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.contentIdentifier != 0) {
		xmlAddChild(node, [self.contentIdentifier xmlNodeForDoc:node->doc elementName:@"contentIdentifier" elementNSPrefix:nil]);
	}
	if(self.contentIdentifierType != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"contentIdentifierType", [tns1_ContentIdentifierTypes_stringFromEnum(self.contentIdentifierType) xmlString]);
	}
}
/* elements */
@synthesize contentIdentifier;
@synthesize contentIdentifierType;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_BookIdentifier *)deserializeNode:(xmlNodePtr)cur
{
	tns1_BookIdentifier *newObject = [[tns1_BookIdentifier new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentIdentifier")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.contentIdentifier = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentIdentifierType")) {
				
				tns1_ContentIdentifierTypes enumRepresentation = tns1_ContentIdentifierTypes_enumFromString(elementString);
				self.contentIdentifierType = enumRepresentation;
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_QuizItem
- (id)init
{
	if((self = [super init])) {
		firstScore = 0;
		bestScore = 0;
		total = 0;
		lastTimestamp = 0;
		numberOfTrials = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(firstScore != nil) [firstScore release];
	if(bestScore != nil) [bestScore release];
	if(total != nil) [total release];
	if(lastTimestamp != nil) [lastTimestamp release];
	if(numberOfTrials != nil) [numberOfTrials release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.firstScore != 0) {
		xmlAddChild(node, [self.firstScore xmlNodeForDoc:node->doc elementName:@"firstScore" elementNSPrefix:nil]);
	}
	if(self.bestScore != 0) {
		xmlAddChild(node, [self.bestScore xmlNodeForDoc:node->doc elementName:@"bestScore" elementNSPrefix:nil]);
	}
	if(self.total != 0) {
		xmlAddChild(node, [self.total xmlNodeForDoc:node->doc elementName:@"total" elementNSPrefix:nil]);
	}
	if(self.lastTimestamp != 0) {
		xmlAddChild(node, [self.lastTimestamp xmlNodeForDoc:node->doc elementName:@"lastTimestamp" elementNSPrefix:nil]);
	}
	if(self.numberOfTrials != 0) {
		xmlAddChild(node, [self.numberOfTrials xmlNodeForDoc:node->doc elementName:@"numberOfTrials" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize firstScore;
@synthesize bestScore;
@synthesize total;
@synthesize lastTimestamp;
@synthesize numberOfTrials;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_QuizItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_QuizItem *newObject = [[tns1_QuizItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "firstScore")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.firstScore = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "bestScore")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.bestScore = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "total")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.total = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lastTimestamp")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lastTimestamp = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "numberOfTrials")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.numberOfTrials = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AggregateByTitleItem
- (id)init
{
	if((self = [super init])) {
		bookIdentifier = 0;
		readingDuration = 0;
		lastReadTimestamp = 0;
		pagesRead = 0;
		quizItem = 0;
		lookupWordList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(bookIdentifier != nil) [bookIdentifier release];
	if(readingDuration != nil) [readingDuration release];
	if(lastReadTimestamp != nil) [lastReadTimestamp release];
	if(pagesRead != nil) [pagesRead release];
	if(quizItem != nil) [quizItem release];
	if(lookupWordList != nil) [lookupWordList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.bookIdentifier != 0) {
		xmlAddChild(node, [self.bookIdentifier xmlNodeForDoc:node->doc elementName:@"bookIdentifier" elementNSPrefix:nil]);
	}
	if(self.readingDuration != 0) {
		xmlAddChild(node, [self.readingDuration xmlNodeForDoc:node->doc elementName:@"readingDuration" elementNSPrefix:nil]);
	}
	if(self.lastReadTimestamp != 0) {
		xmlAddChild(node, [self.lastReadTimestamp xmlNodeForDoc:node->doc elementName:@"lastReadTimestamp" elementNSPrefix:nil]);
	}
	if(self.pagesRead != 0) {
		xmlAddChild(node, [self.pagesRead xmlNodeForDoc:node->doc elementName:@"pagesRead" elementNSPrefix:nil]);
	}
	if(self.quizItem != 0) {
		xmlAddChild(node, [self.quizItem xmlNodeForDoc:node->doc elementName:@"quizItem" elementNSPrefix:nil]);
	}
	if(self.lookupWordList != 0) {
		xmlAddChild(node, [self.lookupWordList xmlNodeForDoc:node->doc elementName:@"lookupWordList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize bookIdentifier;
@synthesize readingDuration;
@synthesize lastReadTimestamp;
@synthesize pagesRead;
@synthesize quizItem;
@synthesize lookupWordList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AggregateByTitleItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AggregateByTitleItem *newObject = [[tns1_AggregateByTitleItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "bookIdentifier")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_BookIdentifier class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.bookIdentifier = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "readingDuration")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.readingDuration = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lastReadTimestamp")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lastReadTimestamp = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "pagesRead")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.pagesRead = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "quizItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_QuizItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.quizItem = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lookupWordList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_LookupWordList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lookupWordList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AggregateByTitleList
- (id)init
{
	if((self = [super init])) {
		aggregateByTitleItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(aggregateByTitleItem != nil) [aggregateByTitleItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.aggregateByTitleItem != 0) {
		for(tns1_AggregateByTitleItem * child in self.aggregateByTitleItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"aggregateByTitleItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize aggregateByTitleItem;
- (void)addAggregateByTitleItem:(tns1_AggregateByTitleItem *)toAdd
{
	if(toAdd != nil) [aggregateByTitleItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AggregateByTitleList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AggregateByTitleList *newObject = [[tns1_AggregateByTitleList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "aggregateByTitleItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AggregateByTitleItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.aggregateByTitleItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AggregateByTitleProfileItem
- (id)init
{
	if((self = [super init])) {
		profileID = 0;
		aggregateByTitleList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(profileID != nil) [profileID release];
	if(aggregateByTitleList != nil) [aggregateByTitleList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.profileID != 0) {
		xmlAddChild(node, [self.profileID xmlNodeForDoc:node->doc elementName:@"profileID" elementNSPrefix:nil]);
	}
	if(self.aggregateByTitleList != 0) {
		xmlAddChild(node, [self.aggregateByTitleList xmlNodeForDoc:node->doc elementName:@"aggregateByTitleList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize profileID;
@synthesize aggregateByTitleList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AggregateByTitleProfileItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AggregateByTitleProfileItem *newObject = [[tns1_AggregateByTitleProfileItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileID")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.profileID = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "aggregateByTitleList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AggregateByTitleList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.aggregateByTitleList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AggregateByTitleProfileList
- (id)init
{
	if((self = [super init])) {
		aggregateByTitleProfileItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(aggregateByTitleProfileItem != nil) [aggregateByTitleProfileItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.aggregateByTitleProfileItem != 0) {
		for(tns1_AggregateByTitleProfileItem * child in self.aggregateByTitleProfileItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"aggregateByTitleProfileItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize aggregateByTitleProfileItem;
- (void)addAggregateByTitleProfileItem:(tns1_AggregateByTitleProfileItem *)toAdd
{
	if(toAdd != nil) [aggregateByTitleProfileItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AggregateByTitleProfileList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AggregateByTitleProfileList *newObject = [[tns1_AggregateByTitleProfileList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "aggregateByTitleProfileItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AggregateByTitleProfileItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.aggregateByTitleProfileItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_DailyAggregateByTitleItem
- (id)init
{
	if((self = [super init])) {
		date = 0;
		bookIdentifier = 0;
		readingDuration = 0;
		pagesRead = 0;
		timesRead = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(date != nil) [date release];
	if(bookIdentifier != nil) [bookIdentifier release];
	if(readingDuration != nil) [readingDuration release];
	if(pagesRead != nil) [pagesRead release];
	if(timesRead != nil) [timesRead release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.date != 0) {
		xmlAddChild(node, [self.date xmlNodeForDoc:node->doc elementName:@"date" elementNSPrefix:nil]);
	}
	if(self.bookIdentifier != 0) {
		xmlAddChild(node, [self.bookIdentifier xmlNodeForDoc:node->doc elementName:@"bookIdentifier" elementNSPrefix:nil]);
	}
	if(self.readingDuration != 0) {
		xmlAddChild(node, [self.readingDuration xmlNodeForDoc:node->doc elementName:@"readingDuration" elementNSPrefix:nil]);
	}
	if(self.pagesRead != 0) {
		xmlAddChild(node, [self.pagesRead xmlNodeForDoc:node->doc elementName:@"pagesRead" elementNSPrefix:nil]);
	}
	if(self.timesRead != 0) {
		xmlAddChild(node, [self.timesRead xmlNodeForDoc:node->doc elementName:@"timesRead" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize date;
@synthesize bookIdentifier;
@synthesize readingDuration;
@synthesize pagesRead;
@synthesize timesRead;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_DailyAggregateByTitleItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_DailyAggregateByTitleItem *newObject = [[tns1_DailyAggregateByTitleItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "date")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.date = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "bookIdentifier")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_BookIdentifier class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.bookIdentifier = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "readingDuration")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.readingDuration = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "pagesRead")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.pagesRead = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "timesRead")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.timesRead = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_DailyAggregateByTitleList
- (id)init
{
	if((self = [super init])) {
		dailyAggregateByTitleItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(dailyAggregateByTitleItem != nil) [dailyAggregateByTitleItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.dailyAggregateByTitleItem != 0) {
		for(tns1_DailyAggregateByTitleItem * child in self.dailyAggregateByTitleItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"dailyAggregateByTitleItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize dailyAggregateByTitleItem;
- (void)addDailyAggregateByTitleItem:(tns1_DailyAggregateByTitleItem *)toAdd
{
	if(toAdd != nil) [dailyAggregateByTitleItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_DailyAggregateByTitleList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_DailyAggregateByTitleList *newObject = [[tns1_DailyAggregateByTitleList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "dailyAggregateByTitleItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_DailyAggregateByTitleItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.dailyAggregateByTitleItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_DailyAggregateByTitleProfileItem
- (id)init
{
	if((self = [super init])) {
		profileID = 0;
		dailyAggregateByTitleList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(profileID != nil) [profileID release];
	if(dailyAggregateByTitleList != nil) [dailyAggregateByTitleList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.profileID != 0) {
		xmlAddChild(node, [self.profileID xmlNodeForDoc:node->doc elementName:@"profileID" elementNSPrefix:nil]);
	}
	if(self.dailyAggregateByTitleList != 0) {
		xmlAddChild(node, [self.dailyAggregateByTitleList xmlNodeForDoc:node->doc elementName:@"dailyAggregateByTitleList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize profileID;
@synthesize dailyAggregateByTitleList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_DailyAggregateByTitleProfileItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_DailyAggregateByTitleProfileItem *newObject = [[tns1_DailyAggregateByTitleProfileItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileID")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.profileID = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "dailyAggregateByTitleList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_DailyAggregateByTitleList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.dailyAggregateByTitleList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_DailyAggregateByTitleProfileList
- (id)init
{
	if((self = [super init])) {
		dailyAggregateByTitleProfileItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(dailyAggregateByTitleProfileItem != nil) [dailyAggregateByTitleProfileItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.dailyAggregateByTitleProfileItem != 0) {
		for(tns1_DailyAggregateByTitleProfileItem * child in self.dailyAggregateByTitleProfileItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"dailyAggregateByTitleProfileItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize dailyAggregateByTitleProfileItem;
- (void)addDailyAggregateByTitleProfileItem:(tns1_DailyAggregateByTitleProfileItem *)toAdd
{
	if(toAdd != nil) [dailyAggregateByTitleProfileItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_DailyAggregateByTitleProfileList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_DailyAggregateByTitleProfileList *newObject = [[tns1_DailyAggregateByTitleProfileList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "dailyAggregateByTitleProfileItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_DailyAggregateByTitleProfileItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.dailyAggregateByTitleProfileItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_BookIdentifierList
- (id)init
{
	if((self = [super init])) {
		bookIdentifier = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(bookIdentifier != nil) [bookIdentifier release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.bookIdentifier != 0) {
		for(tns1_BookIdentifier * child in self.bookIdentifier) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"bookIdentifier" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize bookIdentifier;
- (void)addBookIdentifier:(tns1_BookIdentifier *)toAdd
{
	if(toAdd != nil) [bookIdentifier addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_BookIdentifierList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_BookIdentifierList *newObject = [[tns1_BookIdentifierList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "bookIdentifier")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_BookIdentifier class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.bookIdentifier addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ProfileIdList
- (id)init
{
	if((self = [super init])) {
		profileId = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(profileId != nil) [profileId release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.profileId != 0) {
		for(NSNumber * child in self.profileId) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"profileId" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize profileId;
- (void)addProfileId:(NSNumber *)toAdd
{
	if(toAdd != nil) [profileId addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ProfileIdList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ProfileIdList *newObject = [[tns1_ProfileIdList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.profileId addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_BookShelfEntryItem
- (id)init
{
	if((self = [super init])) {
		ContentIdentifierType = 0;
		contentidentifier = 0;
		drmqualifier = 0;
		format = 0;
		quantity = 0;
		notes = 0;
		profileIdList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(contentidentifier != nil) [contentidentifier release];
	if(format != nil) [format release];
	if(quantity != nil) [quantity release];
	if(notes != nil) [notes release];
	if(profileIdList != nil) [profileIdList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.ContentIdentifierType != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"ContentIdentifierType", [tns1_ContentIdentifierTypes_stringFromEnum(self.ContentIdentifierType) xmlString]);
	}
	if(self.contentidentifier != 0) {
		xmlAddChild(node, [self.contentidentifier xmlNodeForDoc:node->doc elementName:@"contentidentifier" elementNSPrefix:nil]);
	}
	if(self.drmqualifier != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"drmqualifier", [tns1_drmqualifiers_stringFromEnum(self.drmqualifier) xmlString]);
	}
	if(self.format != 0) {
		xmlAddChild(node, [self.format xmlNodeForDoc:node->doc elementName:@"format" elementNSPrefix:nil]);
	}
	if(self.quantity != 0) {
		xmlAddChild(node, [self.quantity xmlNodeForDoc:node->doc elementName:@"quantity" elementNSPrefix:nil]);
	}
	if(self.notes != 0) {
		xmlAddChild(node, [self.notes xmlNodeForDoc:node->doc elementName:@"notes" elementNSPrefix:nil]);
	}
	if(self.profileIdList != 0) {
		xmlAddChild(node, [self.profileIdList xmlNodeForDoc:node->doc elementName:@"profileIdList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize ContentIdentifierType;
@synthesize contentidentifier;
@synthesize drmqualifier;
@synthesize format;
@synthesize quantity;
@synthesize notes;
@synthesize profileIdList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_BookShelfEntryItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_BookShelfEntryItem *newObject = [[tns1_BookShelfEntryItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ContentIdentifierType")) {
				
				tns1_ContentIdentifierTypes enumRepresentation = tns1_ContentIdentifierTypes_enumFromString(elementString);
				self.ContentIdentifierType = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentidentifier")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.contentidentifier = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "drmqualifier")) {
				
				tns1_drmqualifiers enumRepresentation = tns1_drmqualifiers_enumFromString(elementString);
				self.drmqualifier = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "format")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.format = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "quantity")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.quantity = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "notes")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.notes = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileIdList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ProfileIdList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.profileIdList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_BookshelfEntryList
- (id)init
{
	if((self = [super init])) {
		BookShelfEntryItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(BookShelfEntryItem != nil) [BookShelfEntryItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.BookShelfEntryItem != 0) {
		for(tns1_BookShelfEntryItem * child in self.BookShelfEntryItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"BookShelfEntryItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize BookShelfEntryItem;
- (void)addBookShelfEntryItem:(tns1_BookShelfEntryItem *)toAdd
{
	if(toAdd != nil) [BookShelfEntryItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_BookshelfEntryList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_BookshelfEntryList *newObject = [[tns1_BookshelfEntryList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "BookShelfEntryItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_BookShelfEntryItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.BookShelfEntryItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_BookShelfEntryLastPageItem
- (id)init
{
	if((self = [super init])) {
		ContentIdentifierType = 0;
		contentidentifier = 0;
		drmqualifier = 0;
		format = 0;
		LastPage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(contentidentifier != nil) [contentidentifier release];
	if(format != nil) [format release];
	if(LastPage != nil) [LastPage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.ContentIdentifierType != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"ContentIdentifierType", [tns1_ContentIdentifierTypes_stringFromEnum(self.ContentIdentifierType) xmlString]);
	}
	if(self.contentidentifier != 0) {
		xmlAddChild(node, [self.contentidentifier xmlNodeForDoc:node->doc elementName:@"contentidentifier" elementNSPrefix:nil]);
	}
	if(self.drmqualifier != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"drmqualifier", [tns1_drmqualifiers_stringFromEnum(self.drmqualifier) xmlString]);
	}
	if(self.format != 0) {
		xmlAddChild(node, [self.format xmlNodeForDoc:node->doc elementName:@"format" elementNSPrefix:nil]);
	}
	if(self.LastPage != 0) {
		xmlAddChild(node, [self.LastPage xmlNodeForDoc:node->doc elementName:@"LastPage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize ContentIdentifierType;
@synthesize contentidentifier;
@synthesize drmqualifier;
@synthesize format;
@synthesize LastPage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_BookShelfEntryLastPageItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_BookShelfEntryLastPageItem *newObject = [[tns1_BookShelfEntryLastPageItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ContentIdentifierType")) {
				
				tns1_ContentIdentifierTypes enumRepresentation = tns1_ContentIdentifierTypes_enumFromString(elementString);
				self.ContentIdentifierType = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentidentifier")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.contentidentifier = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "drmqualifier")) {
				
				tns1_drmqualifiers enumRepresentation = tns1_drmqualifiers_enumFromString(elementString);
				self.drmqualifier = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "format")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.format = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "LastPage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_LastPage class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.LastPage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_BookshelfEntryLastPageList
- (id)init
{
	if((self = [super init])) {
		BookShelfEntryLastPageItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(BookShelfEntryLastPageItem != nil) [BookShelfEntryLastPageItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.BookShelfEntryLastPageItem != 0) {
		for(tns1_BookShelfEntryLastPageItem * child in self.BookShelfEntryLastPageItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"BookShelfEntryLastPageItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize BookShelfEntryLastPageItem;
- (void)addBookShelfEntryLastPageItem:(tns1_BookShelfEntryLastPageItem *)toAdd
{
	if(toAdd != nil) [BookShelfEntryLastPageItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_BookshelfEntryLastPageList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_BookshelfEntryLastPageList *newObject = [[tns1_BookshelfEntryLastPageList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "BookShelfEntryLastPageItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_BookShelfEntryLastPageItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.BookShelfEntryLastPageItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ProfileBookshelfEntryItem
- (id)init
{
	if((self = [super init])) {
		profileId = 0;
		BookshelfEntryLastPageList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(profileId != nil) [profileId release];
	if(BookshelfEntryLastPageList != nil) [BookshelfEntryLastPageList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.profileId != 0) {
		xmlAddChild(node, [self.profileId xmlNodeForDoc:node->doc elementName:@"profileId" elementNSPrefix:nil]);
	}
	if(self.BookshelfEntryLastPageList != 0) {
		xmlAddChild(node, [self.BookshelfEntryLastPageList xmlNodeForDoc:node->doc elementName:@"BookshelfEntryLastPageList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize profileId;
@synthesize BookshelfEntryLastPageList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ProfileBookshelfEntryItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ProfileBookshelfEntryItem *newObject = [[tns1_ProfileBookshelfEntryItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.profileId = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "BookshelfEntryLastPageList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_BookshelfEntryLastPageList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.BookshelfEntryLastPageList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ProfileBookshelfEntryList
- (id)init
{
	if((self = [super init])) {
		ProfileBookshelfEntryItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(ProfileBookshelfEntryItem != nil) [ProfileBookshelfEntryItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.ProfileBookshelfEntryItem != 0) {
		for(tns1_ProfileBookshelfEntryItem * child in self.ProfileBookshelfEntryItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"ProfileBookshelfEntryItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize ProfileBookshelfEntryItem;
- (void)addProfileBookshelfEntryItem:(tns1_ProfileBookshelfEntryItem *)toAdd
{
	if(toAdd != nil) [ProfileBookshelfEntryItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ProfileBookshelfEntryList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ProfileBookshelfEntryList *newObject = [[tns1_ProfileBookshelfEntryList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ProfileBookshelfEntryItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ProfileBookshelfEntryItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.ProfileBookshelfEntryItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_FavoriteTypesValuesItem
- (id)init
{
	if((self = [super init])) {
		Value = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(Value != nil) [Value release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.Value != 0) {
		xmlAddChild(node, [self.Value xmlNodeForDoc:node->doc elementName:@"Value" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize Value;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_FavoriteTypesValuesItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_FavoriteTypesValuesItem *newObject = [[tns1_FavoriteTypesValuesItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Value")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Value = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_FavoriteTypeValuesList
- (id)init
{
	if((self = [super init])) {
		FavoriteTypesValuesItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(FavoriteTypesValuesItem != nil) [FavoriteTypesValuesItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.FavoriteTypesValuesItem != 0) {
		for(tns1_FavoriteTypesValuesItem * child in self.FavoriteTypesValuesItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"FavoriteTypesValuesItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize FavoriteTypesValuesItem;
- (void)addFavoriteTypesValuesItem:(tns1_FavoriteTypesValuesItem *)toAdd
{
	if(toAdd != nil) [FavoriteTypesValuesItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_FavoriteTypeValuesList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_FavoriteTypeValuesList *newObject = [[tns1_FavoriteTypeValuesList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "FavoriteTypesValuesItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_FavoriteTypesValuesItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.FavoriteTypesValuesItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_FavoriteTypesItem
- (id)init
{
	if((self = [super init])) {
		FavoriteType = 0;
		FavoriteTypeValuesList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(FavoriteTypeValuesList != nil) [FavoriteTypeValuesList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.FavoriteType != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"FavoriteType", [tns1_TopFavoritesTypes_stringFromEnum(self.FavoriteType) xmlString]);
	}
	if(self.FavoriteTypeValuesList != 0) {
		xmlAddChild(node, [self.FavoriteTypeValuesList xmlNodeForDoc:node->doc elementName:@"FavoriteTypeValuesList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize FavoriteType;
@synthesize FavoriteTypeValuesList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_FavoriteTypesItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_FavoriteTypesItem *newObject = [[tns1_FavoriteTypesItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "FavoriteType")) {
				
				tns1_TopFavoritesTypes enumRepresentation = tns1_TopFavoritesTypes_enumFromString(elementString);
				self.FavoriteType = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "FavoriteTypeValuesList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_FavoriteTypeValuesList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.FavoriteTypeValuesList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_FavoriteTypesList
- (id)init
{
	if((self = [super init])) {
		FavoriteTypesItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(FavoriteTypesItem != nil) [FavoriteTypesItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.FavoriteTypesItem != 0) {
		for(tns1_FavoriteTypesItem * child in self.FavoriteTypesItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"FavoriteTypesItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize FavoriteTypesItem;
- (void)addFavoriteTypesItem:(tns1_FavoriteTypesItem *)toAdd
{
	if(toAdd != nil) [FavoriteTypesItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_FavoriteTypesList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_FavoriteTypesList *newObject = [[tns1_FavoriteTypesList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "FavoriteTypesItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_FavoriteTypesItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.FavoriteTypesItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SettingItem
- (id)init
{
	if((self = [super init])) {
		settingName = 0;
		settingValue = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(settingName != nil) [settingName release];
	if(settingValue != nil) [settingValue release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.settingName != 0) {
		xmlAddChild(node, [self.settingName xmlNodeForDoc:node->doc elementName:@"settingName" elementNSPrefix:nil]);
	}
	if(self.settingValue != 0) {
		xmlAddChild(node, [self.settingValue xmlNodeForDoc:node->doc elementName:@"settingValue" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize settingName;
@synthesize settingValue;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SettingItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SettingItem *newObject = [[tns1_SettingItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "settingName")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.settingName = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "settingValue")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.settingValue = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SettingsList
- (id)init
{
	if((self = [super init])) {
		settingItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(settingItem != nil) [settingItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.settingItem != 0) {
		for(tns1_SettingItem * child in self.settingItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"settingItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize settingItem;
- (void)addSettingItem:(tns1_SettingItem *)toAdd
{
	if(toAdd != nil) [settingItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SettingsList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SettingsList *newObject = [[tns1_SettingsList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "settingItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_SettingItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.settingItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SettingStatusItem
- (id)init
{
	if((self = [super init])) {
		settingName = 0;
		statusMessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(settingName != nil) [settingName release];
	if(statusMessage != nil) [statusMessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.settingName != 0) {
		xmlAddChild(node, [self.settingName xmlNodeForDoc:node->doc elementName:@"settingName" elementNSPrefix:nil]);
	}
	if(self.statusMessage != 0) {
		xmlAddChild(node, [self.statusMessage xmlNodeForDoc:node->doc elementName:@"statusMessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize settingName;
@synthesize statusMessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SettingStatusItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SettingStatusItem *newObject = [[tns1_SettingStatusItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "settingName")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.settingName = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusMessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusMessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SettingStatusList
- (id)init
{
	if((self = [super init])) {
		settingStatusItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(settingStatusItem != nil) [settingStatusItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.settingStatusItem != 0) {
		for(tns1_SettingStatusItem * child in self.settingStatusItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"settingStatusItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize settingStatusItem;
- (void)addSettingStatusItem:(tns1_SettingStatusItem *)toAdd
{
	if(toAdd != nil) [settingStatusItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SettingStatusList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SettingStatusList *newObject = [[tns1_SettingStatusList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "settingStatusItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_SettingStatusItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.settingStatusItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AutoAssignProfilesItem
- (id)init
{
	if((self = [super init])) {
		profileId = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(profileId != nil) [profileId release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.profileId != 0) {
		xmlAddChild(node, [self.profileId xmlNodeForDoc:node->doc elementName:@"profileId" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize profileId;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AutoAssignProfilesItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AutoAssignProfilesItem *newObject = [[tns1_AutoAssignProfilesItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.profileId = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AutoAssignProfilesList
- (id)init
{
	if((self = [super init])) {
		AutoAssignProfilesItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(AutoAssignProfilesItem != nil) [AutoAssignProfilesItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.AutoAssignProfilesItem != 0) {
		for(tns1_AutoAssignProfilesItem * child in self.AutoAssignProfilesItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"AutoAssignProfilesItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize AutoAssignProfilesItem;
- (void)addAutoAssignProfilesItem:(tns1_AutoAssignProfilesItem *)toAdd
{
	if(toAdd != nil) [AutoAssignProfilesItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AutoAssignProfilesList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AutoAssignProfilesList *newObject = [[tns1_AutoAssignProfilesList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AutoAssignProfilesItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AutoAssignProfilesItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.AutoAssignProfilesItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ReadBooksProfilesItem
- (id)init
{
	if((self = [super init])) {
		profileId = 0;
		lastReadEvent = 0;
		lastReadDuration = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(profileId != nil) [profileId release];
	if(lastReadEvent != nil) [lastReadEvent release];
	if(lastReadDuration != nil) [lastReadDuration release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.profileId != 0) {
		xmlAddChild(node, [self.profileId xmlNodeForDoc:node->doc elementName:@"profileId" elementNSPrefix:nil]);
	}
	if(self.lastReadEvent != 0) {
		xmlAddChild(node, [self.lastReadEvent xmlNodeForDoc:node->doc elementName:@"lastReadEvent" elementNSPrefix:nil]);
	}
	if(self.lastReadDuration != 0) {
		xmlAddChild(node, [self.lastReadDuration xmlNodeForDoc:node->doc elementName:@"lastReadDuration" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize profileId;
@synthesize lastReadEvent;
@synthesize lastReadDuration;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ReadBooksProfilesItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ReadBooksProfilesItem *newObject = [[tns1_ReadBooksProfilesItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.profileId = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lastReadEvent")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lastReadEvent = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lastReadDuration")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lastReadDuration = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ReadBooksProfilesList
- (id)init
{
	if((self = [super init])) {
		ReadBooksProfilesItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(ReadBooksProfilesItem != nil) [ReadBooksProfilesItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.ReadBooksProfilesItem != 0) {
		for(tns1_ReadBooksProfilesItem * child in self.ReadBooksProfilesItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"ReadBooksProfilesItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize ReadBooksProfilesItem;
- (void)addReadBooksProfilesItem:(tns1_ReadBooksProfilesItem *)toAdd
{
	if(toAdd != nil) [ReadBooksProfilesItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ReadBooksProfilesList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ReadBooksProfilesList *newObject = [[tns1_ReadBooksProfilesList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ReadBooksProfilesItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ReadBooksProfilesItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.ReadBooksProfilesItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ReadBooksItem
- (id)init
{
	if((self = [super init])) {
		ContentIdentifierType = 0;
		contentIdentifier = 0;
		drmqualifier = 0;
		format = 0;
		version = 0;
		ReadBooksProfilesList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(contentIdentifier != nil) [contentIdentifier release];
	if(format != nil) [format release];
	if(version != nil) [version release];
	if(ReadBooksProfilesList != nil) [ReadBooksProfilesList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.ContentIdentifierType != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"ContentIdentifierType", [tns1_ContentIdentifierTypes_stringFromEnum(self.ContentIdentifierType) xmlString]);
	}
	if(self.contentIdentifier != 0) {
		xmlAddChild(node, [self.contentIdentifier xmlNodeForDoc:node->doc elementName:@"contentIdentifier" elementNSPrefix:nil]);
	}
	if(self.drmqualifier != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"drmqualifier", [tns1_drmqualifiers_stringFromEnum(self.drmqualifier) xmlString]);
	}
	if(self.format != 0) {
		xmlAddChild(node, [self.format xmlNodeForDoc:node->doc elementName:@"format" elementNSPrefix:nil]);
	}
	if(self.version != 0) {
		xmlAddChild(node, [self.version xmlNodeForDoc:node->doc elementName:@"version" elementNSPrefix:nil]);
	}
	if(self.ReadBooksProfilesList != 0) {
		xmlAddChild(node, [self.ReadBooksProfilesList xmlNodeForDoc:node->doc elementName:@"ReadBooksProfilesList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize ContentIdentifierType;
@synthesize contentIdentifier;
@synthesize drmqualifier;
@synthesize format;
@synthesize version;
@synthesize ReadBooksProfilesList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ReadBooksItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ReadBooksItem *newObject = [[tns1_ReadBooksItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ContentIdentifierType")) {
				
				tns1_ContentIdentifierTypes enumRepresentation = tns1_ContentIdentifierTypes_enumFromString(elementString);
				self.ContentIdentifierType = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentIdentifier")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.contentIdentifier = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "drmqualifier")) {
				
				tns1_drmqualifiers enumRepresentation = tns1_drmqualifiers_enumFromString(elementString);
				self.drmqualifier = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "format")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.format = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "version")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.version = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ReadBooksProfilesList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ReadBooksProfilesList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ReadBooksProfilesList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ReadBooksList
- (id)init
{
	if((self = [super init])) {
		ReadBooksItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(ReadBooksItem != nil) [ReadBooksItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.ReadBooksItem != 0) {
		for(tns1_ReadBooksItem * child in self.ReadBooksItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"ReadBooksItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize ReadBooksItem;
- (void)addReadBooksItem:(tns1_ReadBooksItem *)toAdd
{
	if(toAdd != nil) [ReadBooksItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ReadBooksList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ReadBooksList *newObject = [[tns1_ReadBooksList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ReadBooksItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ReadBooksItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.ReadBooksItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_LastNRequestReadBooksProfilesItem
- (id)init
{
	if((self = [super init])) {
		profileId = 0;
		bookIdentifierList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(profileId != nil) [profileId release];
	if(bookIdentifierList != nil) [bookIdentifierList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.profileId != 0) {
		xmlAddChild(node, [self.profileId xmlNodeForDoc:node->doc elementName:@"profileId" elementNSPrefix:nil]);
	}
	if(self.bookIdentifierList != 0) {
		xmlAddChild(node, [self.bookIdentifierList xmlNodeForDoc:node->doc elementName:@"bookIdentifierList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize profileId;
@synthesize bookIdentifierList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_LastNRequestReadBooksProfilesItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_LastNRequestReadBooksProfilesItem *newObject = [[tns1_LastNRequestReadBooksProfilesItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.profileId = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "bookIdentifierList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_BookIdentifierList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.bookIdentifierList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_LastNRequestReadBooksProfilesList
- (id)init
{
	if((self = [super init])) {
		LastNRequestReadBooksProfilesItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(LastNRequestReadBooksProfilesItem != nil) [LastNRequestReadBooksProfilesItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.LastNRequestReadBooksProfilesItem != 0) {
		for(tns1_LastNRequestReadBooksProfilesItem * child in self.LastNRequestReadBooksProfilesItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"LastNRequestReadBooksProfilesItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize LastNRequestReadBooksProfilesItem;
- (void)addLastNRequestReadBooksProfilesItem:(tns1_LastNRequestReadBooksProfilesItem *)toAdd
{
	if(toAdd != nil) [LastNRequestReadBooksProfilesItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_LastNRequestReadBooksProfilesList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_LastNRequestReadBooksProfilesList *newObject = [[tns1_LastNRequestReadBooksProfilesList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "LastNRequestReadBooksProfilesItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_LastNRequestReadBooksProfilesItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.LastNRequestReadBooksProfilesItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_LastNReadBooksItem
- (id)init
{
	if((self = [super init])) {
		ContentIdentifierType = 0;
		contentIdentifier = 0;
		drmqualifier = 0;
		format = 0;
		version = 0;
		lastReadEvent = 0;
		lastReadDuration = 0;
		lastReadPages = 0;
		lastPageLocation = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(contentIdentifier != nil) [contentIdentifier release];
	if(format != nil) [format release];
	if(version != nil) [version release];
	if(lastReadEvent != nil) [lastReadEvent release];
	if(lastReadDuration != nil) [lastReadDuration release];
	if(lastReadPages != nil) [lastReadPages release];
	if(lastPageLocation != nil) [lastPageLocation release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.ContentIdentifierType != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"ContentIdentifierType", [tns1_ContentIdentifierTypes_stringFromEnum(self.ContentIdentifierType) xmlString]);
	}
	if(self.contentIdentifier != 0) {
		xmlAddChild(node, [self.contentIdentifier xmlNodeForDoc:node->doc elementName:@"contentIdentifier" elementNSPrefix:nil]);
	}
	if(self.drmqualifier != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"drmqualifier", [tns1_drmqualifiers_stringFromEnum(self.drmqualifier) xmlString]);
	}
	if(self.format != 0) {
		xmlAddChild(node, [self.format xmlNodeForDoc:node->doc elementName:@"format" elementNSPrefix:nil]);
	}
	if(self.version != 0) {
		xmlAddChild(node, [self.version xmlNodeForDoc:node->doc elementName:@"version" elementNSPrefix:nil]);
	}
	if(self.lastReadEvent != 0) {
		xmlAddChild(node, [self.lastReadEvent xmlNodeForDoc:node->doc elementName:@"lastReadEvent" elementNSPrefix:nil]);
	}
	if(self.lastReadDuration != 0) {
		xmlAddChild(node, [self.lastReadDuration xmlNodeForDoc:node->doc elementName:@"lastReadDuration" elementNSPrefix:nil]);
	}
	if(self.lastReadPages != 0) {
		xmlAddChild(node, [self.lastReadPages xmlNodeForDoc:node->doc elementName:@"lastReadPages" elementNSPrefix:nil]);
	}
	if(self.lastPageLocation != 0) {
		xmlAddChild(node, [self.lastPageLocation xmlNodeForDoc:node->doc elementName:@"lastPageLocation" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize ContentIdentifierType;
@synthesize contentIdentifier;
@synthesize drmqualifier;
@synthesize format;
@synthesize version;
@synthesize lastReadEvent;
@synthesize lastReadDuration;
@synthesize lastReadPages;
@synthesize lastPageLocation;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_LastNReadBooksItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_LastNReadBooksItem *newObject = [[tns1_LastNReadBooksItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ContentIdentifierType")) {
				
				tns1_ContentIdentifierTypes enumRepresentation = tns1_ContentIdentifierTypes_enumFromString(elementString);
				self.ContentIdentifierType = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentIdentifier")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.contentIdentifier = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "drmqualifier")) {
				
				tns1_drmqualifiers enumRepresentation = tns1_drmqualifiers_enumFromString(elementString);
				self.drmqualifier = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "format")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.format = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "version")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.version = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lastReadEvent")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lastReadEvent = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lastReadDuration")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lastReadDuration = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lastReadPages")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lastReadPages = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lastPageLocation")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lastPageLocation = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_LastNReadBooksList
- (id)init
{
	if((self = [super init])) {
		LastNReadBooksItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(LastNReadBooksItem != nil) [LastNReadBooksItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.LastNReadBooksItem != 0) {
		for(tns1_LastNReadBooksItem * child in self.LastNReadBooksItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"LastNReadBooksItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize LastNReadBooksItem;
- (void)addLastNReadBooksItem:(tns1_LastNReadBooksItem *)toAdd
{
	if(toAdd != nil) [LastNReadBooksItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_LastNReadBooksList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_LastNReadBooksList *newObject = [[tns1_LastNReadBooksList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "LastNReadBooksItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_LastNReadBooksItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.LastNReadBooksItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_LastNResponseReadBooksProfilesItem
- (id)init
{
	if((self = [super init])) {
		profileId = 0;
		LastNReadBooksList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(profileId != nil) [profileId release];
	if(LastNReadBooksList != nil) [LastNReadBooksList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.profileId != 0) {
		xmlAddChild(node, [self.profileId xmlNodeForDoc:node->doc elementName:@"profileId" elementNSPrefix:nil]);
	}
	if(self.LastNReadBooksList != 0) {
		xmlAddChild(node, [self.LastNReadBooksList xmlNodeForDoc:node->doc elementName:@"LastNReadBooksList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize profileId;
@synthesize LastNReadBooksList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_LastNResponseReadBooksProfilesItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_LastNResponseReadBooksProfilesItem *newObject = [[tns1_LastNResponseReadBooksProfilesItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.profileId = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "LastNReadBooksList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_LastNReadBooksList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.LastNReadBooksList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_LastNResponseReadBooksProfilesList
- (id)init
{
	if((self = [super init])) {
		LastNResponseReadBooksProfilesItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(LastNResponseReadBooksProfilesItem != nil) [LastNResponseReadBooksProfilesItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.LastNResponseReadBooksProfilesItem != 0) {
		for(tns1_LastNResponseReadBooksProfilesItem * child in self.LastNResponseReadBooksProfilesItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"LastNResponseReadBooksProfilesItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize LastNResponseReadBooksProfilesItem;
- (void)addLastNResponseReadBooksProfilesItem:(tns1_LastNResponseReadBooksProfilesItem *)toAdd
{
	if(toAdd != nil) [LastNResponseReadBooksProfilesItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_LastNResponseReadBooksProfilesList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_LastNResponseReadBooksProfilesList *newObject = [[tns1_LastNResponseReadBooksProfilesList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "LastNResponseReadBooksProfilesItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_LastNResponseReadBooksProfilesItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.LastNResponseReadBooksProfilesItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_LastNRequestWordsItem
- (id)init
{
	if((self = [super init])) {
		profileId = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(profileId != nil) [profileId release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.profileId != 0) {
		xmlAddChild(node, [self.profileId xmlNodeForDoc:node->doc elementName:@"profileId" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize profileId;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_LastNRequestWordsItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_LastNRequestWordsItem *newObject = [[tns1_LastNRequestWordsItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.profileId = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_LastNRequestWordsList
- (id)init
{
	if((self = [super init])) {
		LastNRequestWordsItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(LastNRequestWordsItem != nil) [LastNRequestWordsItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.LastNRequestWordsItem != 0) {
		for(tns1_LastNRequestWordsItem * child in self.LastNRequestWordsItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"LastNRequestWordsItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize LastNRequestWordsItem;
- (void)addLastNRequestWordsItem:(tns1_LastNRequestWordsItem *)toAdd
{
	if(toAdd != nil) [LastNRequestWordsItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_LastNRequestWordsList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_LastNRequestWordsList *newObject = [[tns1_LastNRequestWordsList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "LastNRequestWordsItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_LastNRequestWordsItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.LastNRequestWordsItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_LastNLookedUpWordsItem
- (id)init
{
	if((self = [super init])) {
		lookupWord = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(lookupWord != nil) [lookupWord release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.lookupWord != 0) {
		xmlAddChild(node, [self.lookupWord xmlNodeForDoc:node->doc elementName:@"lookupWord" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize lookupWord;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_LastNLookedUpWordsItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_LastNLookedUpWordsItem *newObject = [[tns1_LastNLookedUpWordsItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lookupWord")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lookupWord = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_LastNLookedUpWordsList
- (id)init
{
	if((self = [super init])) {
		LastNLookedUpWordsItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(LastNLookedUpWordsItem != nil) [LastNLookedUpWordsItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.LastNLookedUpWordsItem != 0) {
		for(tns1_LastNLookedUpWordsItem * child in self.LastNLookedUpWordsItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"LastNLookedUpWordsItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize LastNLookedUpWordsItem;
- (void)addLastNLookedUpWordsItem:(tns1_LastNLookedUpWordsItem *)toAdd
{
	if(toAdd != nil) [LastNLookedUpWordsItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_LastNLookedUpWordsList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_LastNLookedUpWordsList *newObject = [[tns1_LastNLookedUpWordsList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "LastNLookedUpWordsItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_LastNLookedUpWordsItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.LastNLookedUpWordsItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_LastNResponseWordsItem
- (id)init
{
	if((self = [super init])) {
		profileId = 0;
		LastNLookedUpWordsList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(profileId != nil) [profileId release];
	if(LastNLookedUpWordsList != nil) [LastNLookedUpWordsList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.profileId != 0) {
		xmlAddChild(node, [self.profileId xmlNodeForDoc:node->doc elementName:@"profileId" elementNSPrefix:nil]);
	}
	if(self.LastNLookedUpWordsList != 0) {
		xmlAddChild(node, [self.LastNLookedUpWordsList xmlNodeForDoc:node->doc elementName:@"LastNLookedUpWordsList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize profileId;
@synthesize LastNLookedUpWordsList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_LastNResponseWordsItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_LastNResponseWordsItem *newObject = [[tns1_LastNResponseWordsItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.profileId = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "LastNLookedUpWordsList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_LastNLookedUpWordsList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.LastNLookedUpWordsList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_LastNResponseWordsList
- (id)init
{
	if((self = [super init])) {
		LastNResponseWordsItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(LastNResponseWordsItem != nil) [LastNResponseWordsItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.LastNResponseWordsItem != 0) {
		for(tns1_LastNResponseWordsItem * child in self.LastNResponseWordsItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"LastNResponseWordsItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize LastNResponseWordsItem;
- (void)addLastNResponseWordsItem:(tns1_LastNResponseWordsItem *)toAdd
{
	if(toAdd != nil) [LastNResponseWordsItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_LastNResponseWordsList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_LastNResponseWordsList *newObject = [[tns1_LastNResponseWordsList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "LastNResponseWordsItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_LastNResponseWordsItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.LastNResponseWordsItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_NoteItem
- (id)init
{
	if((self = [super init])) {
		actor = 0;
		noteText = 0;
		csrUserName = 0;
		timestamp = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(actor != nil) [actor release];
	if(noteText != nil) [noteText release];
	if(csrUserName != nil) [csrUserName release];
	if(timestamp != nil) [timestamp release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.actor != 0) {
		xmlAddChild(node, [self.actor xmlNodeForDoc:node->doc elementName:@"actor" elementNSPrefix:nil]);
	}
	if(self.noteText != 0) {
		xmlAddChild(node, [self.noteText xmlNodeForDoc:node->doc elementName:@"noteText" elementNSPrefix:nil]);
	}
	if(self.csrUserName != 0) {
		xmlAddChild(node, [self.csrUserName xmlNodeForDoc:node->doc elementName:@"csrUserName" elementNSPrefix:nil]);
	}
	if(self.timestamp != 0) {
		xmlAddChild(node, [self.timestamp xmlNodeForDoc:node->doc elementName:@"timestamp" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize actor;
@synthesize noteText;
@synthesize csrUserName;
@synthesize timestamp;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_NoteItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_NoteItem *newObject = [[tns1_NoteItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "actor")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.actor = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "noteText")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.noteText = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "csrUserName")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.csrUserName = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "timestamp")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.timestamp = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_NotesList
- (id)init
{
	if((self = [super init])) {
		noteItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(noteItem != nil) [noteItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.noteItem != 0) {
		for(tns1_NoteItem * child in self.noteItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"noteItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize noteItem;
- (void)addNoteItem:(tns1_NoteItem *)toAdd
{
	if(toAdd != nil) [noteItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_NotesList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_NotesList *newObject = [[tns1_NotesList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "noteItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_NoteItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.noteItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_DefaultBooksItem
- (id)init
{
	if((self = [super init])) {
		contentidentifier = 0;
		contentIdentifierType = 0;
		DRMQualifier = 0;
		Format = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(contentidentifier != nil) [contentidentifier release];
	if(Format != nil) [Format release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.contentidentifier != 0) {
		xmlAddChild(node, [self.contentidentifier xmlNodeForDoc:node->doc elementName:@"contentidentifier" elementNSPrefix:nil]);
	}
	if(self.contentIdentifierType != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"contentIdentifierType", [tns1_ContentIdentifierTypes_stringFromEnum(self.contentIdentifierType) xmlString]);
	}
	if(self.DRMQualifier != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"DRMQualifier", [tns1_drmqualifiers_stringFromEnum(self.DRMQualifier) xmlString]);
	}
	if(self.Format != 0) {
		xmlAddChild(node, [self.Format xmlNodeForDoc:node->doc elementName:@"Format" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize contentidentifier;
@synthesize contentIdentifierType;
@synthesize DRMQualifier;
@synthesize Format;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_DefaultBooksItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_DefaultBooksItem *newObject = [[tns1_DefaultBooksItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentidentifier")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.contentidentifier = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentIdentifierType")) {
				
				tns1_ContentIdentifierTypes enumRepresentation = tns1_ContentIdentifierTypes_enumFromString(elementString);
				self.contentIdentifierType = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "DRMQualifier")) {
				
				tns1_drmqualifiers enumRepresentation = tns1_drmqualifiers_enumFromString(elementString);
				self.DRMQualifier = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Format")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Format = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_DefaultBooksList
- (id)init
{
	if((self = [super init])) {
		DefaultBooksItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(DefaultBooksItem != nil) [DefaultBooksItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.DefaultBooksItem != 0) {
		for(tns1_DefaultBooksItem * child in self.DefaultBooksItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"DefaultBooksItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize DefaultBooksItem;
- (void)addDefaultBooksItem:(tns1_DefaultBooksItem *)toAdd
{
	if(toAdd != nil) [DefaultBooksItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_DefaultBooksList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_DefaultBooksList *newObject = [[tns1_DefaultBooksList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "DefaultBooksItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_DefaultBooksItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.DefaultBooksItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AssignBooksToAllUsersItem
- (id)init
{
	if((self = [super init])) {
		userKey = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(userKey != nil) [userKey release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.userKey != 0) {
		xmlAddChild(node, [self.userKey xmlNodeForDoc:node->doc elementName:@"userKey" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize userKey;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AssignBooksToAllUsersItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AssignBooksToAllUsersItem *newObject = [[tns1_AssignBooksToAllUsersItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "userKey")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.userKey = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AssignBooksToAllUsersList
- (id)init
{
	if((self = [super init])) {
		AssignBooksToAllUsersItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(AssignBooksToAllUsersItem != nil) [AssignBooksToAllUsersItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.AssignBooksToAllUsersItem != 0) {
		for(tns1_AssignBooksToAllUsersItem * child in self.AssignBooksToAllUsersItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"AssignBooksToAllUsersItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize AssignBooksToAllUsersItem;
- (void)addAssignBooksToAllUsersItem:(tns1_AssignBooksToAllUsersItem *)toAdd
{
	if(toAdd != nil) [AssignBooksToAllUsersItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AssignBooksToAllUsersList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AssignBooksToAllUsersList *newObject = [[tns1_AssignBooksToAllUsersList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AssignBooksToAllUsersItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AssignBooksToAllUsersItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.AssignBooksToAllUsersItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AssignBooksToAllUsersBooksItem
- (id)init
{
	if((self = [super init])) {
		contentidentifier = 0;
		contentIdentifierType = 0;
		DRMQualifier = 0;
		Format = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(contentidentifier != nil) [contentidentifier release];
	if(Format != nil) [Format release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.contentidentifier != 0) {
		xmlAddChild(node, [self.contentidentifier xmlNodeForDoc:node->doc elementName:@"contentidentifier" elementNSPrefix:nil]);
	}
	if(self.contentIdentifierType != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"contentIdentifierType", [tns1_ContentIdentifierTypes_stringFromEnum(self.contentIdentifierType) xmlString]);
	}
	if(self.DRMQualifier != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"DRMQualifier", [tns1_drmqualifiers_stringFromEnum(self.DRMQualifier) xmlString]);
	}
	if(self.Format != 0) {
		xmlAddChild(node, [self.Format xmlNodeForDoc:node->doc elementName:@"Format" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize contentidentifier;
@synthesize contentIdentifierType;
@synthesize DRMQualifier;
@synthesize Format;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AssignBooksToAllUsersBooksItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AssignBooksToAllUsersBooksItem *newObject = [[tns1_AssignBooksToAllUsersBooksItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentidentifier")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.contentidentifier = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentIdentifierType")) {
				
				tns1_ContentIdentifierTypes enumRepresentation = tns1_ContentIdentifierTypes_enumFromString(elementString);
				self.contentIdentifierType = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "DRMQualifier")) {
				
				tns1_drmqualifiers enumRepresentation = tns1_drmqualifiers_enumFromString(elementString);
				self.DRMQualifier = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Format")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Format = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AssignBooksToAllUsersBooksList
- (id)init
{
	if((self = [super init])) {
		AssignBooksToAllUsersBooksItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(AssignBooksToAllUsersBooksItem != nil) [AssignBooksToAllUsersBooksItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.AssignBooksToAllUsersBooksItem != 0) {
		for(tns1_AssignBooksToAllUsersBooksItem * child in self.AssignBooksToAllUsersBooksItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"AssignBooksToAllUsersBooksItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize AssignBooksToAllUsersBooksItem;
- (void)addAssignBooksToAllUsersBooksItem:(tns1_AssignBooksToAllUsersBooksItem *)toAdd
{
	if(toAdd != nil) [AssignBooksToAllUsersBooksItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AssignBooksToAllUsersBooksList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AssignBooksToAllUsersBooksList *newObject = [[tns1_AssignBooksToAllUsersBooksList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AssignBooksToAllUsersBooksItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AssignBooksToAllUsersBooksItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.AssignBooksToAllUsersBooksItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListRatingsContentItem
- (id)init
{
	if((self = [super init])) {
		contentIdentifier = 0;
		contentIdentifierType = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(contentIdentifier != nil) [contentIdentifier release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.contentIdentifier != 0) {
		xmlAddChild(node, [self.contentIdentifier xmlNodeForDoc:node->doc elementName:@"contentIdentifier" elementNSPrefix:nil]);
	}
	if(self.contentIdentifierType != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"contentIdentifierType", [tns1_ContentIdentifierTypes_stringFromEnum(self.contentIdentifierType) xmlString]);
	}
}
/* elements */
@synthesize contentIdentifier;
@synthesize contentIdentifierType;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListRatingsContentItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListRatingsContentItem *newObject = [[tns1_ListRatingsContentItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentIdentifier")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.contentIdentifier = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentIdentifierType")) {
				
				tns1_ContentIdentifierTypes enumRepresentation = tns1_ContentIdentifierTypes_enumFromString(elementString);
				self.contentIdentifierType = enumRepresentation;
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListRatingsContentList
- (id)init
{
	if((self = [super init])) {
		listRatingsContentItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(listRatingsContentItem != nil) [listRatingsContentItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.listRatingsContentItem != 0) {
		for(tns1_ListRatingsContentItem * child in self.listRatingsContentItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"listRatingsContentItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize listRatingsContentItem;
- (void)addListRatingsContentItem:(tns1_ListRatingsContentItem *)toAdd
{
	if(toAdd != nil) [listRatingsContentItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListRatingsContentList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListRatingsContentList *newObject = [[tns1_ListRatingsContentList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "listRatingsContentItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ListRatingsContentItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.listRatingsContentItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListRatingsItem
- (id)init
{
	if((self = [super init])) {
		listRatingsContentList = 0;
		profileId = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(listRatingsContentList != nil) [listRatingsContentList release];
	if(profileId != nil) [profileId release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.listRatingsContentList != 0) {
		xmlAddChild(node, [self.listRatingsContentList xmlNodeForDoc:node->doc elementName:@"listRatingsContentList" elementNSPrefix:nil]);
	}
	if(self.profileId != 0) {
		xmlAddChild(node, [self.profileId xmlNodeForDoc:node->doc elementName:@"profileId" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize listRatingsContentList;
@synthesize profileId;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListRatingsItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListRatingsItem *newObject = [[tns1_ListRatingsItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "listRatingsContentList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ListRatingsContentList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.listRatingsContentList = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.profileId = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListRatingsRequestList
- (id)init
{
	if((self = [super init])) {
		listRatingsItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(listRatingsItem != nil) [listRatingsItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.listRatingsItem != 0) {
		for(tns1_ListRatingsItem * child in self.listRatingsItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"listRatingsItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize listRatingsItem;
- (void)addListRatingsItem:(tns1_ListRatingsItem *)toAdd
{
	if(toAdd != nil) [listRatingsItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListRatingsRequestList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListRatingsRequestList *newObject = [[tns1_ListRatingsRequestList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "listRatingsItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ListRatingsItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.listRatingsItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ProfileRatingsStatusItem
- (id)init
{
	if((self = [super init])) {
		contentIdentifier = 0;
		contentIdentifierType = 0;
		rating = 0;
		statusMessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(contentIdentifier != nil) [contentIdentifier release];
	if(rating != nil) [rating release];
	if(statusMessage != nil) [statusMessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.contentIdentifier != 0) {
		xmlAddChild(node, [self.contentIdentifier xmlNodeForDoc:node->doc elementName:@"contentIdentifier" elementNSPrefix:nil]);
	}
	if(self.contentIdentifierType != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"contentIdentifierType", [tns1_ContentIdentifierTypes_stringFromEnum(self.contentIdentifierType) xmlString]);
	}
	if(self.rating != 0) {
		xmlAddChild(node, [self.rating xmlNodeForDoc:node->doc elementName:@"rating" elementNSPrefix:nil]);
	}
	if(self.statusMessage != 0) {
		xmlAddChild(node, [self.statusMessage xmlNodeForDoc:node->doc elementName:@"statusMessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize contentIdentifier;
@synthesize contentIdentifierType;
@synthesize rating;
@synthesize statusMessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ProfileRatingsStatusItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ProfileRatingsStatusItem *newObject = [[tns1_ProfileRatingsStatusItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentIdentifier")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.contentIdentifier = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentIdentifierType")) {
				
				tns1_ContentIdentifierTypes enumRepresentation = tns1_ContentIdentifierTypes_enumFromString(elementString);
				self.contentIdentifierType = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "rating")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_Rating class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.rating = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusMessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusMessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ProfileRatingsStatusList
- (id)init
{
	if((self = [super init])) {
		profileRatingsStatusItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(profileRatingsStatusItem != nil) [profileRatingsStatusItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.profileRatingsStatusItem != 0) {
		for(tns1_ProfileRatingsStatusItem * child in self.profileRatingsStatusItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"profileRatingsStatusItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize profileRatingsStatusItem;
- (void)addProfileRatingsStatusItem:(tns1_ProfileRatingsStatusItem *)toAdd
{
	if(toAdd != nil) [profileRatingsStatusItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ProfileRatingsStatusList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ProfileRatingsStatusList *newObject = [[tns1_ProfileRatingsStatusList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileRatingsStatusItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ProfileRatingsStatusItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.profileRatingsStatusItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_RatingsStatusItem
- (id)init
{
	if((self = [super init])) {
		profileId = 0;
		statusMessage = 0;
		profileRatingsStatusList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(profileId != nil) [profileId release];
	if(statusMessage != nil) [statusMessage release];
	if(profileRatingsStatusList != nil) [profileRatingsStatusList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.profileId != 0) {
		xmlAddChild(node, [self.profileId xmlNodeForDoc:node->doc elementName:@"profileId" elementNSPrefix:nil]);
	}
	if(self.statusMessage != 0) {
		xmlAddChild(node, [self.statusMessage xmlNodeForDoc:node->doc elementName:@"statusMessage" elementNSPrefix:nil]);
	}
	if(self.profileRatingsStatusList != 0) {
		xmlAddChild(node, [self.profileRatingsStatusList xmlNodeForDoc:node->doc elementName:@"profileRatingsStatusList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize profileId;
@synthesize statusMessage;
@synthesize profileRatingsStatusList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_RatingsStatusItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_RatingsStatusItem *newObject = [[tns1_RatingsStatusItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.profileId = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusMessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusMessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileRatingsStatusList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ProfileRatingsStatusList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.profileRatingsStatusList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_RatingsStatusList
- (id)init
{
	if((self = [super init])) {
		ratingsStatusItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(ratingsStatusItem != nil) [ratingsStatusItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.ratingsStatusItem != 0) {
		for(tns1_RatingsStatusItem * child in self.ratingsStatusItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"ratingsStatusItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize ratingsStatusItem;
- (void)addRatingsStatusItem:(tns1_RatingsStatusItem *)toAdd
{
	if(toAdd != nil) [ratingsStatusItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_RatingsStatusList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_RatingsStatusList *newObject = [[tns1_RatingsStatusList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ratingsStatusItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_RatingsStatusItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.ratingsStatusItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ProfileRatingsItem
- (id)init
{
	if((self = [super init])) {
		contentIdentifier = 0;
		contentIdentifierType = 0;
		rating = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(contentIdentifier != nil) [contentIdentifier release];
	if(rating != nil) [rating release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.contentIdentifier != 0) {
		xmlAddChild(node, [self.contentIdentifier xmlNodeForDoc:node->doc elementName:@"contentIdentifier" elementNSPrefix:nil]);
	}
	if(self.contentIdentifierType != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"contentIdentifierType", [tns1_ContentIdentifierTypes_stringFromEnum(self.contentIdentifierType) xmlString]);
	}
	if(self.rating != 0) {
		xmlAddChild(node, [self.rating xmlNodeForDoc:node->doc elementName:@"rating" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize contentIdentifier;
@synthesize contentIdentifierType;
@synthesize rating;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ProfileRatingsItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ProfileRatingsItem *newObject = [[tns1_ProfileRatingsItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentIdentifier")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.contentIdentifier = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentIdentifierType")) {
				
				tns1_ContentIdentifierTypes enumRepresentation = tns1_ContentIdentifierTypes_enumFromString(elementString);
				self.contentIdentifierType = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "rating")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_Rating class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.rating = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ProfileRatingsList
- (id)init
{
	if((self = [super init])) {
		profileRatingsItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(profileRatingsItem != nil) [profileRatingsItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.profileRatingsItem != 0) {
		for(tns1_ProfileRatingsItem * child in self.profileRatingsItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"profileRatingsItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize profileRatingsItem;
- (void)addProfileRatingsItem:(tns1_ProfileRatingsItem *)toAdd
{
	if(toAdd != nil) [profileRatingsItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ProfileRatingsList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ProfileRatingsList *newObject = [[tns1_ProfileRatingsList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileRatingsItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ProfileRatingsItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.profileRatingsItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_RatingsItem
- (id)init
{
	if((self = [super init])) {
		profileRatingsList = 0;
		profileId = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(profileRatingsList != nil) [profileRatingsList release];
	if(profileId != nil) [profileId release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.profileRatingsList != 0) {
		xmlAddChild(node, [self.profileRatingsList xmlNodeForDoc:node->doc elementName:@"profileRatingsList" elementNSPrefix:nil]);
	}
	if(self.profileId != 0) {
		xmlAddChild(node, [self.profileId xmlNodeForDoc:node->doc elementName:@"profileId" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize profileRatingsList;
@synthesize profileId;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_RatingsItem *)deserializeNode:(xmlNodePtr)cur
{
	tns1_RatingsItem *newObject = [[tns1_RatingsItem new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileRatingsList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ProfileRatingsList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.profileRatingsList = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.profileId = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_RatingsList
- (id)init
{
	if((self = [super init])) {
		ratingsItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(ratingsItem != nil) [ratingsItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.ratingsItem != 0) {
		for(tns1_RatingsItem * child in self.ratingsItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"ratingsItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize ratingsItem;
- (void)addRatingsItem:(tns1_RatingsItem *)toAdd
{
	if(toAdd != nil) [ratingsItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_RatingsList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_RatingsList *newObject = [[tns1_RatingsList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ratingsItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_RatingsItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.ratingsItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_TokenExchange
- (id)init
{
	if((self = [super init])) {
		ptoken = 0;
		vaid = 0;
		deviceKey = 0;
		impersonationkey = 0;
		UserName = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(ptoken != nil) [ptoken release];
	if(vaid != nil) [vaid release];
	if(deviceKey != nil) [deviceKey release];
	if(impersonationkey != nil) [impersonationkey release];
	if(UserName != nil) [UserName release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.ptoken != 0) {
		xmlAddChild(node, [self.ptoken xmlNodeForDoc:node->doc elementName:@"ptoken" elementNSPrefix:nil]);
	}
	if(self.vaid != 0) {
		xmlAddChild(node, [self.vaid xmlNodeForDoc:node->doc elementName:@"vaid" elementNSPrefix:nil]);
	}
	if(self.deviceKey != 0) {
		xmlAddChild(node, [self.deviceKey xmlNodeForDoc:node->doc elementName:@"deviceKey" elementNSPrefix:nil]);
	}
	if(self.impersonationkey != 0) {
		xmlAddChild(node, [self.impersonationkey xmlNodeForDoc:node->doc elementName:@"impersonationkey" elementNSPrefix:nil]);
	}
	if(self.UserName != 0) {
		xmlAddChild(node, [self.UserName xmlNodeForDoc:node->doc elementName:@"UserName" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize ptoken;
@synthesize vaid;
@synthesize deviceKey;
@synthesize impersonationkey;
@synthesize UserName;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_TokenExchange *)deserializeNode:(xmlNodePtr)cur
{
	tns1_TokenExchange *newObject = [[tns1_TokenExchange new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ptoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ptoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "vaid")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.vaid = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "deviceKey")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.deviceKey = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "impersonationkey")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.impersonationkey = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "UserName")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.UserName = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_TokenExchangeResponse
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
		expiresIn = 0;
		userKey = 0;
		userType = 0;
		deviceIsDeregistered = 0;
		isNewUser = 0;
		isCoppa = 0;
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	if(expiresIn != nil) [expiresIn release];
	if(userKey != nil) [userKey release];
	if(userType != nil) [userType release];
	if(deviceIsDeregistered != nil) [deviceIsDeregistered release];
	if(isNewUser != nil) [isNewUser release];
	if(isCoppa != nil) [isCoppa release];
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
	if(self.expiresIn != 0) {
		xmlAddChild(node, [self.expiresIn xmlNodeForDoc:node->doc elementName:@"expiresIn" elementNSPrefix:nil]);
	}
	if(self.userKey != 0) {
		xmlAddChild(node, [self.userKey xmlNodeForDoc:node->doc elementName:@"userKey" elementNSPrefix:nil]);
	}
	if(self.userType != 0) {
		xmlAddChild(node, [self.userType xmlNodeForDoc:node->doc elementName:@"userType" elementNSPrefix:nil]);
	}
	if(self.deviceIsDeregistered != 0) {
		xmlAddChild(node, [self.deviceIsDeregistered xmlNodeForDoc:node->doc elementName:@"deviceIsDeregistered" elementNSPrefix:nil]);
	}
	if(self.isNewUser != 0) {
		xmlAddChild(node, [self.isNewUser xmlNodeForDoc:node->doc elementName:@"isNewUser" elementNSPrefix:nil]);
	}
	if(self.isCoppa != 0) {
		xmlAddChild(node, [self.isCoppa xmlNodeForDoc:node->doc elementName:@"isCoppa" elementNSPrefix:nil]);
	}
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
@synthesize expiresIn;
@synthesize userKey;
@synthesize userType;
@synthesize deviceIsDeregistered;
@synthesize isNewUser;
@synthesize isCoppa;
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_TokenExchangeResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_TokenExchangeResponse *newObject = [[tns1_TokenExchangeResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "expiresIn")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.expiresIn = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "userKey")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.userKey = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "userType")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.userType = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "deviceIsDeregistered")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.deviceIsDeregistered = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "isNewUser")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.isNewUser = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "isCoppa")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.isCoppa = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SharedTokenExchangeRequest
- (id)init
{
	if((self = [super init])) {
		ptoken = 0;
		vaid = 0;
		deviceKey = 0;
		impersonationkey = 0;
		UserName = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(ptoken != nil) [ptoken release];
	if(vaid != nil) [vaid release];
	if(deviceKey != nil) [deviceKey release];
	if(impersonationkey != nil) [impersonationkey release];
	if(UserName != nil) [UserName release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.ptoken != 0) {
		xmlAddChild(node, [self.ptoken xmlNodeForDoc:node->doc elementName:@"ptoken" elementNSPrefix:nil]);
	}
	if(self.vaid != 0) {
		xmlAddChild(node, [self.vaid xmlNodeForDoc:node->doc elementName:@"vaid" elementNSPrefix:nil]);
	}
	if(self.deviceKey != 0) {
		xmlAddChild(node, [self.deviceKey xmlNodeForDoc:node->doc elementName:@"deviceKey" elementNSPrefix:nil]);
	}
	if(self.impersonationkey != 0) {
		xmlAddChild(node, [self.impersonationkey xmlNodeForDoc:node->doc elementName:@"impersonationkey" elementNSPrefix:nil]);
	}
	if(self.UserName != 0) {
		xmlAddChild(node, [self.UserName xmlNodeForDoc:node->doc elementName:@"UserName" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize ptoken;
@synthesize vaid;
@synthesize deviceKey;
@synthesize impersonationkey;
@synthesize UserName;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SharedTokenExchangeRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SharedTokenExchangeRequest *newObject = [[tns1_SharedTokenExchangeRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ptoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ptoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "vaid")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.vaid = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "deviceKey")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.deviceKey = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "impersonationkey")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.impersonationkey = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "UserName")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.UserName = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SharedTokenExchangeResponse
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
		expires = 0;
		expiresIn = 0;
		ip = 0;
		userKey = 0;
		userhash = 0;
		userType = 0;
		deviceIsDeregistered = 0;
		isNewUser = 0;
		isCoppa = 0;
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	if(expires != nil) [expires release];
	if(expiresIn != nil) [expiresIn release];
	if(ip != nil) [ip release];
	if(userKey != nil) [userKey release];
	if(userhash != nil) [userhash release];
	if(userType != nil) [userType release];
	if(deviceIsDeregistered != nil) [deviceIsDeregistered release];
	if(isNewUser != nil) [isNewUser release];
	if(isCoppa != nil) [isCoppa release];
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
	if(self.expires != 0) {
		xmlAddChild(node, [self.expires xmlNodeForDoc:node->doc elementName:@"expires" elementNSPrefix:nil]);
	}
	if(self.expiresIn != 0) {
		xmlAddChild(node, [self.expiresIn xmlNodeForDoc:node->doc elementName:@"expiresIn" elementNSPrefix:nil]);
	}
	if(self.ip != 0) {
		xmlAddChild(node, [self.ip xmlNodeForDoc:node->doc elementName:@"ip" elementNSPrefix:nil]);
	}
	if(self.userKey != 0) {
		xmlAddChild(node, [self.userKey xmlNodeForDoc:node->doc elementName:@"userKey" elementNSPrefix:nil]);
	}
	if(self.userhash != 0) {
		xmlAddChild(node, [self.userhash xmlNodeForDoc:node->doc elementName:@"userhash" elementNSPrefix:nil]);
	}
	if(self.userType != 0) {
		xmlAddChild(node, [self.userType xmlNodeForDoc:node->doc elementName:@"userType" elementNSPrefix:nil]);
	}
	if(self.deviceIsDeregistered != 0) {
		xmlAddChild(node, [self.deviceIsDeregistered xmlNodeForDoc:node->doc elementName:@"deviceIsDeregistered" elementNSPrefix:nil]);
	}
	if(self.isNewUser != 0) {
		xmlAddChild(node, [self.isNewUser xmlNodeForDoc:node->doc elementName:@"isNewUser" elementNSPrefix:nil]);
	}
	if(self.isCoppa != 0) {
		xmlAddChild(node, [self.isCoppa xmlNodeForDoc:node->doc elementName:@"isCoppa" elementNSPrefix:nil]);
	}
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
@synthesize expires;
@synthesize expiresIn;
@synthesize ip;
@synthesize userKey;
@synthesize userhash;
@synthesize userType;
@synthesize deviceIsDeregistered;
@synthesize isNewUser;
@synthesize isCoppa;
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SharedTokenExchangeResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SharedTokenExchangeResponse *newObject = [[tns1_SharedTokenExchangeResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "expires")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.expires = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "expiresIn")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.expiresIn = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ip")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ip = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "userKey")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.userKey = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "userhash")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.userhash = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "userType")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.userType = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "deviceIsDeregistered")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.deviceIsDeregistered = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "isNewUser")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.isNewUser = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "isCoppa")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.isCoppa = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AuthenticateDeviceRequest
- (id)init
{
	if((self = [super init])) {
		vaid = 0;
		deviceKey = 0;
		userKey = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(vaid != nil) [vaid release];
	if(deviceKey != nil) [deviceKey release];
	if(userKey != nil) [userKey release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.vaid != 0) {
		xmlAddChild(node, [self.vaid xmlNodeForDoc:node->doc elementName:@"vaid" elementNSPrefix:nil]);
	}
	if(self.deviceKey != 0) {
		xmlAddChild(node, [self.deviceKey xmlNodeForDoc:node->doc elementName:@"deviceKey" elementNSPrefix:nil]);
	}
	if(self.userKey != 0) {
		xmlAddChild(node, [self.userKey xmlNodeForDoc:node->doc elementName:@"userKey" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize vaid;
@synthesize deviceKey;
@synthesize userKey;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AuthenticateDeviceRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AuthenticateDeviceRequest *newObject = [[tns1_AuthenticateDeviceRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "vaid")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.vaid = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "deviceKey")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.deviceKey = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "userKey")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.userKey = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AuthenticateDeviceResponse
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
		expiresIn = 0;
		deviceIsDeregistered = 0;
		userKey = 0;
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	if(expiresIn != nil) [expiresIn release];
	if(deviceIsDeregistered != nil) [deviceIsDeregistered release];
	if(userKey != nil) [userKey release];
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
	if(self.expiresIn != 0) {
		xmlAddChild(node, [self.expiresIn xmlNodeForDoc:node->doc elementName:@"expiresIn" elementNSPrefix:nil]);
	}
	if(self.deviceIsDeregistered != 0) {
		xmlAddChild(node, [self.deviceIsDeregistered xmlNodeForDoc:node->doc elementName:@"deviceIsDeregistered" elementNSPrefix:nil]);
	}
	if(self.userKey != 0) {
		xmlAddChild(node, [self.userKey xmlNodeForDoc:node->doc elementName:@"userKey" elementNSPrefix:nil]);
	}
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
@synthesize expiresIn;
@synthesize deviceIsDeregistered;
@synthesize userKey;
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AuthenticateDeviceResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AuthenticateDeviceResponse *newObject = [[tns1_AuthenticateDeviceResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "expiresIn")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.expiresIn = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "deviceIsDeregistered")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.deviceIsDeregistered = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "userKey")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.userKey = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_RenewTokenRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_RenewTokenRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_RenewTokenRequest *newObject = [[tns1_RenewTokenRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_RenewTokenResponse
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
		expiresIn = 0;
		userKey = 0;
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	if(expiresIn != nil) [expiresIn release];
	if(userKey != nil) [userKey release];
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
	if(self.expiresIn != 0) {
		xmlAddChild(node, [self.expiresIn xmlNodeForDoc:node->doc elementName:@"expiresIn" elementNSPrefix:nil]);
	}
	if(self.userKey != 0) {
		xmlAddChild(node, [self.userKey xmlNodeForDoc:node->doc elementName:@"userKey" elementNSPrefix:nil]);
	}
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
@synthesize expiresIn;
@synthesize userKey;
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_RenewTokenResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_RenewTokenResponse *newObject = [[tns1_RenewTokenResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "expiresIn")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.expiresIn = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "userKey")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.userKey = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListBooksAssignmentRequest
- (id)init
{
	if((self = [super init])) {
		authToken = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authToken != nil) [authToken release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authToken != 0) {
		xmlAddChild(node, [self.authToken xmlNodeForDoc:node->doc elementName:@"authToken" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authToken;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListBooksAssignmentRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListBooksAssignmentRequest *newObject = [[tns1_ListBooksAssignmentRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authToken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authToken = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_BooksAssignment
- (id)init
{
	if((self = [super init])) {
		ContentIdentifier = 0;
		ContentIdentifierType = 0;
		DRMQualifier = 0;
		Format = 0;
		version = 0;
		averageRating = 0;
		numVotes = 0;
		lastOrderDate = 0;
		defaultAssignment = 0;
		freeBook = 0;
		lastVersion = 0;
		quantity = 0;
		quantityInit = 0;
		contentProfileList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(ContentIdentifier != nil) [ContentIdentifier release];
	if(Format != nil) [Format release];
	if(version != nil) [version release];
	if(averageRating != nil) [averageRating release];
	if(numVotes != nil) [numVotes release];
	if(lastOrderDate != nil) [lastOrderDate release];
	if(defaultAssignment != nil) [defaultAssignment release];
	if(freeBook != nil) [freeBook release];
	if(lastVersion != nil) [lastVersion release];
	if(quantity != nil) [quantity release];
	if(quantityInit != nil) [quantityInit release];
	if(contentProfileList != nil) [contentProfileList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.ContentIdentifier != 0) {
		xmlAddChild(node, [self.ContentIdentifier xmlNodeForDoc:node->doc elementName:@"ContentIdentifier" elementNSPrefix:nil]);
	}
	if(self.ContentIdentifierType != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"ContentIdentifierType", [tns1_ContentIdentifierTypes_stringFromEnum(self.ContentIdentifierType) xmlString]);
	}
	if(self.DRMQualifier != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"DRMQualifier", [tns1_drmqualifiers_stringFromEnum(self.DRMQualifier) xmlString]);
	}
	if(self.Format != 0) {
		xmlAddChild(node, [self.Format xmlNodeForDoc:node->doc elementName:@"Format" elementNSPrefix:nil]);
	}
	if(self.version != 0) {
		xmlAddChild(node, [self.version xmlNodeForDoc:node->doc elementName:@"version" elementNSPrefix:nil]);
	}
	if(self.averageRating != 0) {
		xmlAddChild(node, [self.averageRating xmlNodeForDoc:node->doc elementName:@"averageRating" elementNSPrefix:nil]);
	}
	if(self.numVotes != 0) {
		xmlAddChild(node, [self.numVotes xmlNodeForDoc:node->doc elementName:@"numVotes" elementNSPrefix:nil]);
	}
	if(self.lastOrderDate != 0) {
		xmlAddChild(node, [self.lastOrderDate xmlNodeForDoc:node->doc elementName:@"lastOrderDate" elementNSPrefix:nil]);
	}
	if(self.defaultAssignment != 0) {
		xmlAddChild(node, [self.defaultAssignment xmlNodeForDoc:node->doc elementName:@"defaultAssignment" elementNSPrefix:nil]);
	}
	if(self.freeBook != 0) {
		xmlAddChild(node, [self.freeBook xmlNodeForDoc:node->doc elementName:@"freeBook" elementNSPrefix:nil]);
	}
	if(self.lastVersion != 0) {
		xmlAddChild(node, [self.lastVersion xmlNodeForDoc:node->doc elementName:@"lastVersion" elementNSPrefix:nil]);
	}
	if(self.quantity != 0) {
		xmlAddChild(node, [self.quantity xmlNodeForDoc:node->doc elementName:@"quantity" elementNSPrefix:nil]);
	}
	if(self.quantityInit != 0) {
		xmlAddChild(node, [self.quantityInit xmlNodeForDoc:node->doc elementName:@"quantityInit" elementNSPrefix:nil]);
	}
	if(self.contentProfileList != 0) {
		xmlAddChild(node, [self.contentProfileList xmlNodeForDoc:node->doc elementName:@"contentProfileList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize ContentIdentifier;
@synthesize ContentIdentifierType;
@synthesize DRMQualifier;
@synthesize Format;
@synthesize version;
@synthesize averageRating;
@synthesize numVotes;
@synthesize lastOrderDate;
@synthesize defaultAssignment;
@synthesize freeBook;
@synthesize lastVersion;
@synthesize quantity;
@synthesize quantityInit;
@synthesize contentProfileList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_BooksAssignment *)deserializeNode:(xmlNodePtr)cur
{
	tns1_BooksAssignment *newObject = [[tns1_BooksAssignment new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ContentIdentifier")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ContentIdentifier = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ContentIdentifierType")) {
				
				tns1_ContentIdentifierTypes enumRepresentation = tns1_ContentIdentifierTypes_enumFromString(elementString);
				self.ContentIdentifierType = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "DRMQualifier")) {
				
				tns1_drmqualifiers enumRepresentation = tns1_drmqualifiers_enumFromString(elementString);
				self.DRMQualifier = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Format")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Format = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "version")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.version = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "averageRating")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.averageRating = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "numVotes")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.numVotes = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lastOrderDate")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lastOrderDate = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "defaultAssignment")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.defaultAssignment = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "freeBook")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.freeBook = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lastVersion")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lastVersion = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "quantity")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.quantity = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "quantityInit")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.quantityInit = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentProfileList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ContentProfileList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.contentProfileList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_booksAssignmentList
- (id)init
{
	if((self = [super init])) {
		booksAssignment = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(booksAssignment != nil) [booksAssignment release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.booksAssignment != 0) {
		for(tns1_BooksAssignment * child in self.booksAssignment) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"booksAssignment" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize booksAssignment;
- (void)addBooksAssignment:(tns1_BooksAssignment *)toAdd
{
	if(toAdd != nil) [booksAssignment addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_booksAssignmentList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_booksAssignmentList *newObject = [[tns1_booksAssignmentList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "booksAssignment")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_BooksAssignment class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.booksAssignment addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListBooksAssignmentResponse
- (id)init
{
	if((self = [super init])) {
		statusMessage = 0;
		booksAssignmentList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusMessage != nil) [statusMessage release];
	if(booksAssignmentList != nil) [booksAssignmentList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusMessage != 0) {
		xmlAddChild(node, [self.statusMessage xmlNodeForDoc:node->doc elementName:@"statusMessage" elementNSPrefix:nil]);
	}
	if(self.booksAssignmentList != 0) {
		xmlAddChild(node, [self.booksAssignmentList xmlNodeForDoc:node->doc elementName:@"booksAssignmentList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusMessage;
@synthesize booksAssignmentList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListBooksAssignmentResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListBooksAssignmentResponse *newObject = [[tns1_ListBooksAssignmentResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusMessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusMessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "booksAssignmentList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_booksAssignmentList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.booksAssignmentList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListUserContent
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListUserContent *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListUserContent *newObject = [[tns1_ListUserContent new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_UserContentList
- (id)init
{
	if((self = [super init])) {
		userContentItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(userContentItem != nil) [userContentItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.userContentItem != 0) {
		for(tns1_UserContentItem * child in self.userContentItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"userContentItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize userContentItem;
- (void)addUserContentItem:(tns1_UserContentItem *)toAdd
{
	if(toAdd != nil) [userContentItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_UserContentList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_UserContentList *newObject = [[tns1_UserContentList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "userContentItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_UserContentItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.userContentItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListUserContentResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
		userContentList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	if(userContentList != nil) [userContentList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
	if(self.userContentList != 0) {
		xmlAddChild(node, [self.userContentList xmlNodeForDoc:node->doc elementName:@"userContentList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
@synthesize userContentList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListUserContentResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListUserContentResponse *newObject = [[tns1_ListUserContentResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "userContentList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_UserContentList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.userContentList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListContentMetadata
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
		includeurls = 0;
		coverURLOnly = 0;
		isbn13s = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	if(includeurls != nil) [includeurls release];
	if(coverURLOnly != nil) [coverURLOnly release];
	if(isbn13s != nil) [isbn13s release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
	if(self.includeurls != 0) {
		xmlAddChild(node, [self.includeurls xmlNodeForDoc:node->doc elementName:@"includeurls" elementNSPrefix:nil]);
	}
	if(self.coverURLOnly != 0) {
		xmlAddChild(node, [self.coverURLOnly xmlNodeForDoc:node->doc elementName:@"coverURLOnly" elementNSPrefix:nil]);
	}
	if(self.isbn13s != 0) {
		for(tns1_isbnItem * child in self.isbn13s) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"isbn13s" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize authtoken;
@synthesize includeurls;
@synthesize coverURLOnly;
@synthesize isbn13s;
- (void)addIsbn13s:(tns1_isbnItem *)toAdd
{
	if(toAdd != nil) [isbn13s addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListContentMetadata *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListContentMetadata *newObject = [[tns1_ListContentMetadata new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "includeurls")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.includeurls = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "coverURLOnly")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.coverURLOnly = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "isbn13s")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_isbnItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.isbn13s addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ContentMetadataList
- (id)init
{
	if((self = [super init])) {
		ContentMetadataItem = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(ContentMetadataItem != nil) [ContentMetadataItem release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.ContentMetadataItem != 0) {
		for(tns1_ContentMetadataItem * child in self.ContentMetadataItem) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"ContentMetadataItem" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize ContentMetadataItem;
- (void)addContentMetadataItem:(tns1_ContentMetadataItem *)toAdd
{
	if(toAdd != nil) [ContentMetadataItem addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ContentMetadataList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ContentMetadataList *newObject = [[tns1_ContentMetadataList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ContentMetadataItem")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ContentMetadataItem class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.ContentMetadataItem addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListContentMetadataResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
		ContentMetadataList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	if(ContentMetadataList != nil) [ContentMetadataList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
	if(self.ContentMetadataList != 0) {
		xmlAddChild(node, [self.ContentMetadataList xmlNodeForDoc:node->doc elementName:@"ContentMetadataList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
@synthesize ContentMetadataList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListContentMetadataResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListContentMetadataResponse *newObject = [[tns1_ListContentMetadataResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ContentMetadataList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ContentMetadataList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ContentMetadataList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_IsEntitledToLicenseResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
		isEntitled = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	if(isEntitled != nil) [isEntitled release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
	if(self.isEntitled != 0) {
		xmlAddChild(node, [self.isEntitled xmlNodeForDoc:node->doc elementName:@"isEntitled" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
@synthesize isEntitled;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_IsEntitledToLicenseResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_IsEntitledToLicenseResponse *newObject = [[tns1_IsEntitledToLicenseResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "isEntitled")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.isEntitled = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_EntitledToLicenseRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
		contentidentifier = 0;
		ContentIdentifierType = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	if(contentidentifier != nil) [contentidentifier release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
	if(self.contentidentifier != 0) {
		xmlAddChild(node, [self.contentidentifier xmlNodeForDoc:node->doc elementName:@"contentidentifier" elementNSPrefix:nil]);
	}
	if(self.ContentIdentifierType != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"ContentIdentifierType", [tns1_ContentIdentifierTypes_stringFromEnum(self.ContentIdentifierType) xmlString]);
	}
}
/* elements */
@synthesize authtoken;
@synthesize contentidentifier;
@synthesize ContentIdentifierType;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_EntitledToLicenseRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_EntitledToLicenseRequest *newObject = [[tns1_EntitledToLicenseRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentidentifier")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.contentidentifier = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ContentIdentifierType")) {
				
				tns1_ContentIdentifierTypes enumRepresentation = tns1_ContentIdentifierTypes_enumFromString(elementString);
				self.ContentIdentifierType = enumRepresentation;
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SaveReadingStatisticsDetailedRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
		ReadingStatsDetailList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	if(ReadingStatsDetailList != nil) [ReadingStatsDetailList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
	if(self.ReadingStatsDetailList != 0) {
		xmlAddChild(node, [self.ReadingStatsDetailList xmlNodeForDoc:node->doc elementName:@"ReadingStatsDetailList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
@synthesize ReadingStatsDetailList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SaveReadingStatisticsDetailedRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SaveReadingStatisticsDetailedRequest *newObject = [[tns1_SaveReadingStatisticsDetailedRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ReadingStatsDetailList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ReadingStatsDetailList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ReadingStatsDetailList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SaveReadingStatisticsDetailedResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SaveReadingStatisticsDetailedResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SaveReadingStatisticsDetailedResponse *newObject = [[tns1_SaveReadingStatisticsDetailedResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListReadingStatisticsAggregateRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
		profileId = 0;
		aggregationPeriod = 0;
		countDeletedBooks = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	if(profileId != nil) [profileId release];
	if(countDeletedBooks != nil) [countDeletedBooks release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
	if(self.profileId != 0) {
		xmlAddChild(node, [self.profileId xmlNodeForDoc:node->doc elementName:@"profileId" elementNSPrefix:nil]);
	}
	if(self.aggregationPeriod != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"aggregationPeriod", [tns1_aggregationPeriod_stringFromEnum(self.aggregationPeriod) xmlString]);
	}
	if(self.countDeletedBooks != 0) {
		xmlAddChild(node, [self.countDeletedBooks xmlNodeForDoc:node->doc elementName:@"countDeletedBooks" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
@synthesize profileId;
@synthesize aggregationPeriod;
@synthesize countDeletedBooks;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListReadingStatisticsAggregateRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListReadingStatisticsAggregateRequest *newObject = [[tns1_ListReadingStatisticsAggregateRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.profileId = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "aggregationPeriod")) {
				
				tns1_aggregationPeriod enumRepresentation = tns1_aggregationPeriod_enumFromString(elementString);
				self.aggregationPeriod = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "countDeletedBooks")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.countDeletedBooks = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListReadingStatisticsAggregateResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
		ReadingStatsAggregateList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	if(ReadingStatsAggregateList != nil) [ReadingStatsAggregateList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
	if(self.ReadingStatsAggregateList != 0) {
		xmlAddChild(node, [self.ReadingStatsAggregateList xmlNodeForDoc:node->doc elementName:@"ReadingStatsAggregateList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
@synthesize ReadingStatsAggregateList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListReadingStatisticsAggregateResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListReadingStatisticsAggregateResponse *newObject = [[tns1_ListReadingStatisticsAggregateResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ReadingStatsAggregateList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ReadingStatsAggregateList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ReadingStatsAggregateList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListReadingStatisticsDetailedRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
		profileId = 0;
		begindate = 0;
		enddate = 0;
		countDeletedBooks = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	if(profileId != nil) [profileId release];
	if(begindate != nil) [begindate release];
	if(enddate != nil) [enddate release];
	if(countDeletedBooks != nil) [countDeletedBooks release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
	if(self.profileId != 0) {
		xmlAddChild(node, [self.profileId xmlNodeForDoc:node->doc elementName:@"profileId" elementNSPrefix:nil]);
	}
	if(self.begindate != 0) {
		xmlAddChild(node, [self.begindate xmlNodeForDoc:node->doc elementName:@"begindate" elementNSPrefix:nil]);
	}
	if(self.enddate != 0) {
		xmlAddChild(node, [self.enddate xmlNodeForDoc:node->doc elementName:@"enddate" elementNSPrefix:nil]);
	}
	if(self.countDeletedBooks != 0) {
		xmlAddChild(node, [self.countDeletedBooks xmlNodeForDoc:node->doc elementName:@"countDeletedBooks" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
@synthesize profileId;
@synthesize begindate;
@synthesize enddate;
@synthesize countDeletedBooks;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListReadingStatisticsDetailedRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListReadingStatisticsDetailedRequest *newObject = [[tns1_ListReadingStatisticsDetailedRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.profileId = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "begindate")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.begindate = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "enddate")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.enddate = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "countDeletedBooks")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.countDeletedBooks = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListReadingStatisticsDetailedResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
		ReadingStatsDetailList = 0;
		ItemsCount = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	if(ReadingStatsDetailList != nil) [ReadingStatsDetailList release];
	if(ItemsCount != nil) [ItemsCount release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
	if(self.ReadingStatsDetailList != 0) {
		xmlAddChild(node, [self.ReadingStatsDetailList xmlNodeForDoc:node->doc elementName:@"ReadingStatsDetailList" elementNSPrefix:nil]);
	}
	if(self.ItemsCount != 0) {
		xmlAddChild(node, [self.ItemsCount xmlNodeForDoc:node->doc elementName:@"ItemsCount" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
@synthesize ReadingStatsDetailList;
@synthesize ItemsCount;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListReadingStatisticsDetailedResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListReadingStatisticsDetailedResponse *newObject = [[tns1_ListReadingStatisticsDetailedResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ReadingStatsDetailList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ReadingStatsDetailList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ReadingStatsDetailList = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ItemsCount")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ItemsCount class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ItemsCount = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListReadingStatisticsMonthlyAverageRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
		profileIdList = 0;
		numberOfMonths = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	if(profileIdList != nil) [profileIdList release];
	if(numberOfMonths != nil) [numberOfMonths release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
	if(self.profileIdList != 0) {
		xmlAddChild(node, [self.profileIdList xmlNodeForDoc:node->doc elementName:@"profileIdList" elementNSPrefix:nil]);
	}
	if(self.numberOfMonths != 0) {
		xmlAddChild(node, [self.numberOfMonths xmlNodeForDoc:node->doc elementName:@"numberOfMonths" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
@synthesize profileIdList;
@synthesize numberOfMonths;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListReadingStatisticsMonthlyAverageRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListReadingStatisticsMonthlyAverageRequest *newObject = [[tns1_ListReadingStatisticsMonthlyAverageRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileIdList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ProfileIdList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.profileIdList = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "numberOfMonths")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.numberOfMonths = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListReadingStatisticsMonthlyAverageResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
		monthlyAverageProfileList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	if(monthlyAverageProfileList != nil) [monthlyAverageProfileList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
	if(self.monthlyAverageProfileList != 0) {
		xmlAddChild(node, [self.monthlyAverageProfileList xmlNodeForDoc:node->doc elementName:@"monthlyAverageProfileList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
@synthesize monthlyAverageProfileList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListReadingStatisticsMonthlyAverageResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListReadingStatisticsMonthlyAverageResponse *newObject = [[tns1_ListReadingStatisticsMonthlyAverageResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "monthlyAverageProfileList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_MonthlyAverageProfileList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.monthlyAverageProfileList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListReadingStatisticsAggregateByTitleRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
		profileIdList = 0;
		bookIdentifierList = 0;
		maxWordCount = 0;
		lastReadDate = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	if(profileIdList != nil) [profileIdList release];
	if(bookIdentifierList != nil) [bookIdentifierList release];
	if(maxWordCount != nil) [maxWordCount release];
	if(lastReadDate != nil) [lastReadDate release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
	if(self.profileIdList != 0) {
		xmlAddChild(node, [self.profileIdList xmlNodeForDoc:node->doc elementName:@"profileIdList" elementNSPrefix:nil]);
	}
	if(self.bookIdentifierList != 0) {
		xmlAddChild(node, [self.bookIdentifierList xmlNodeForDoc:node->doc elementName:@"bookIdentifierList" elementNSPrefix:nil]);
	}
	if(self.maxWordCount != 0) {
		xmlAddChild(node, [self.maxWordCount xmlNodeForDoc:node->doc elementName:@"maxWordCount" elementNSPrefix:nil]);
	}
	if(self.lastReadDate != 0) {
		xmlAddChild(node, [self.lastReadDate xmlNodeForDoc:node->doc elementName:@"lastReadDate" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
@synthesize profileIdList;
@synthesize bookIdentifierList;
@synthesize maxWordCount;
@synthesize lastReadDate;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListReadingStatisticsAggregateByTitleRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListReadingStatisticsAggregateByTitleRequest *newObject = [[tns1_ListReadingStatisticsAggregateByTitleRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileIdList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ProfileIdList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.profileIdList = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "bookIdentifierList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_BookIdentifierList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.bookIdentifierList = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "maxWordCount")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.maxWordCount = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lastReadDate")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lastReadDate = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListReadingStatisticsAggregateByTitleResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
		aggregateByTitleProfileList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	if(aggregateByTitleProfileList != nil) [aggregateByTitleProfileList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
	if(self.aggregateByTitleProfileList != 0) {
		xmlAddChild(node, [self.aggregateByTitleProfileList xmlNodeForDoc:node->doc elementName:@"aggregateByTitleProfileList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
@synthesize aggregateByTitleProfileList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListReadingStatisticsAggregateByTitleResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListReadingStatisticsAggregateByTitleResponse *newObject = [[tns1_ListReadingStatisticsAggregateByTitleResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "aggregateByTitleProfileList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AggregateByTitleProfileList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.aggregateByTitleProfileList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListReadingStatisticsDailyAggregateByTitleRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
		profileIdList = 0;
		numberOfDays = 0;
		bookIdentifierList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	if(profileIdList != nil) [profileIdList release];
	if(numberOfDays != nil) [numberOfDays release];
	if(bookIdentifierList != nil) [bookIdentifierList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
	if(self.profileIdList != 0) {
		xmlAddChild(node, [self.profileIdList xmlNodeForDoc:node->doc elementName:@"profileIdList" elementNSPrefix:nil]);
	}
	if(self.numberOfDays != 0) {
		xmlAddChild(node, [self.numberOfDays xmlNodeForDoc:node->doc elementName:@"numberOfDays" elementNSPrefix:nil]);
	}
	if(self.bookIdentifierList != 0) {
		xmlAddChild(node, [self.bookIdentifierList xmlNodeForDoc:node->doc elementName:@"bookIdentifierList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
@synthesize profileIdList;
@synthesize numberOfDays;
@synthesize bookIdentifierList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListReadingStatisticsDailyAggregateByTitleRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListReadingStatisticsDailyAggregateByTitleRequest *newObject = [[tns1_ListReadingStatisticsDailyAggregateByTitleRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "profileIdList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ProfileIdList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.profileIdList = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "numberOfDays")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.numberOfDays = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "bookIdentifierList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_BookIdentifierList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.bookIdentifierList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListReadingStatisticsDailyAggregateByTitleResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
		dailyAggregateByTitleProfileList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	if(dailyAggregateByTitleProfileList != nil) [dailyAggregateByTitleProfileList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
	if(self.dailyAggregateByTitleProfileList != 0) {
		xmlAddChild(node, [self.dailyAggregateByTitleProfileList xmlNodeForDoc:node->doc elementName:@"dailyAggregateByTitleProfileList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
@synthesize dailyAggregateByTitleProfileList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListReadingStatisticsDailyAggregateByTitleResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListReadingStatisticsDailyAggregateByTitleResponse *newObject = [[tns1_ListReadingStatisticsDailyAggregateByTitleResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "dailyAggregateByTitleProfileList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_DailyAggregateByTitleProfileList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.dailyAggregateByTitleProfileList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SaveProfileContentAnnotationsRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
		AnnotationsList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	if(AnnotationsList != nil) [AnnotationsList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
	if(self.AnnotationsList != 0) {
		xmlAddChild(node, [self.AnnotationsList xmlNodeForDoc:node->doc elementName:@"AnnotationsList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
@synthesize AnnotationsList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SaveProfileContentAnnotationsRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SaveProfileContentAnnotationsRequest *newObject = [[tns1_SaveProfileContentAnnotationsRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AnnotationsList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AnnotationsList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.AnnotationsList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SaveProfileContentAnnotationsResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
		AnnotationStatusForRatingsList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	if(AnnotationStatusForRatingsList != nil) [AnnotationStatusForRatingsList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
	if(self.AnnotationStatusForRatingsList != 0) {
		xmlAddChild(node, [self.AnnotationStatusForRatingsList xmlNodeForDoc:node->doc elementName:@"AnnotationStatusForRatingsList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
@synthesize AnnotationStatusForRatingsList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SaveProfileContentAnnotationsResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SaveProfileContentAnnotationsResponse *newObject = [[tns1_SaveProfileContentAnnotationsResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AnnotationStatusForRatingsList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AnnotationStatusList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.AnnotationStatusForRatingsList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListProfileContentAnnotationsRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
		AnnotationsRequestList = 0;
		includeRemoved = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	if(AnnotationsRequestList != nil) [AnnotationsRequestList release];
	if(includeRemoved != nil) [includeRemoved release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
	if(self.AnnotationsRequestList != 0) {
		xmlAddChild(node, [self.AnnotationsRequestList xmlNodeForDoc:node->doc elementName:@"AnnotationsRequestList" elementNSPrefix:nil]);
	}
	if(self.includeRemoved != 0) {
		xmlAddChild(node, [self.includeRemoved xmlNodeForDoc:node->doc elementName:@"includeRemoved" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
@synthesize AnnotationsRequestList;
@synthesize includeRemoved;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListProfileContentAnnotationsRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListProfileContentAnnotationsRequest *newObject = [[tns1_ListProfileContentAnnotationsRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AnnotationsRequestList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AnnotationsRequestList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.AnnotationsRequestList = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "includeRemoved")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.includeRemoved = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListProfileContentAnnotationsResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
		AnnotationsList = 0;
		ItemsCount = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	if(AnnotationsList != nil) [AnnotationsList release];
	if(ItemsCount != nil) [ItemsCount release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
	if(self.AnnotationsList != 0) {
		xmlAddChild(node, [self.AnnotationsList xmlNodeForDoc:node->doc elementName:@"AnnotationsList" elementNSPrefix:nil]);
	}
	if(self.ItemsCount != 0) {
		xmlAddChild(node, [self.ItemsCount xmlNodeForDoc:node->doc elementName:@"ItemsCount" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
@synthesize AnnotationsList;
@synthesize ItemsCount;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListProfileContentAnnotationsResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListProfileContentAnnotationsResponse *newObject = [[tns1_ListProfileContentAnnotationsResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AnnotationsList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AnnotationsList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.AnnotationsList = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ItemsCount")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ItemsCount class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ItemsCount = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_GetUserProfilesRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_GetUserProfilesRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_GetUserProfilesRequest *newObject = [[tns1_GetUserProfilesRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_GetUserProfilesResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
		ProfileList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	if(ProfileList != nil) [ProfileList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
	if(self.ProfileList != 0) {
		xmlAddChild(node, [self.ProfileList xmlNodeForDoc:node->doc elementName:@"ProfileList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
@synthesize ProfileList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_GetUserProfilesResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_GetUserProfilesResponse *newObject = [[tns1_GetUserProfilesResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ProfileList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ProfileList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ProfileList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SaveUserProfilesRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
		SaveProfileList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	if(SaveProfileList != nil) [SaveProfileList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
	if(self.SaveProfileList != 0) {
		xmlAddChild(node, [self.SaveProfileList xmlNodeForDoc:node->doc elementName:@"SaveProfileList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
@synthesize SaveProfileList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SaveUserProfilesRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SaveUserProfilesRequest *newObject = [[tns1_SaveUserProfilesRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "SaveProfileList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_SaveProfileList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.SaveProfileList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SaveUserProfilesResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
		ProfileStatusList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	if(ProfileStatusList != nil) [ProfileStatusList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
	if(self.ProfileStatusList != 0) {
		xmlAddChild(node, [self.ProfileStatusList xmlNodeForDoc:node->doc elementName:@"ProfileStatusList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
@synthesize ProfileStatusList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SaveUserProfilesResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SaveUserProfilesResponse *newObject = [[tns1_SaveUserProfilesResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ProfileStatusList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ProfileStatusList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ProfileStatusList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListApplicationSettingsRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListApplicationSettingsRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListApplicationSettingsRequest *newObject = [[tns1_ListApplicationSettingsRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListApplicationSettingsResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
		settingsList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	if(settingsList != nil) [settingsList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
	if(self.settingsList != 0) {
		xmlAddChild(node, [self.settingsList xmlNodeForDoc:node->doc elementName:@"settingsList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
@synthesize settingsList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListApplicationSettingsResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListApplicationSettingsResponse *newObject = [[tns1_ListApplicationSettingsResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "settingsList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_SettingsList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.settingsList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SaveContentProfileAssignmentRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
		ContentProfileAssignmentList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	if(ContentProfileAssignmentList != nil) [ContentProfileAssignmentList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
	if(self.ContentProfileAssignmentList != 0) {
		xmlAddChild(node, [self.ContentProfileAssignmentList xmlNodeForDoc:node->doc elementName:@"ContentProfileAssignmentList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
@synthesize ContentProfileAssignmentList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SaveContentProfileAssignmentRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SaveContentProfileAssignmentRequest *newObject = [[tns1_SaveContentProfileAssignmentRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ContentProfileAssignmentList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ContentProfileAssignmentList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ContentProfileAssignmentList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SaveContentProfileAssignmentResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SaveContentProfileAssignmentResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SaveContentProfileAssignmentResponse *newObject = [[tns1_SaveContentProfileAssignmentResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_GetDeviceInfoRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_GetDeviceInfoRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_GetDeviceInfoRequest *newObject = [[tns1_GetDeviceInfoRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_GetDeviceInfoResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
		DeviceInfoList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	if(DeviceInfoList != nil) [DeviceInfoList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
	if(self.DeviceInfoList != 0) {
		xmlAddChild(node, [self.DeviceInfoList xmlNodeForDoc:node->doc elementName:@"DeviceInfoList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
@synthesize DeviceInfoList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_GetDeviceInfoResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_GetDeviceInfoResponse *newObject = [[tns1_GetDeviceInfoResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "DeviceInfoList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_DeviceList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.DeviceInfoList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SaveDeviceInfoRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
		SaveDeviceList = 0;
		action = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	if(SaveDeviceList != nil) [SaveDeviceList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
	if(self.SaveDeviceList != 0) {
		xmlAddChild(node, [self.SaveDeviceList xmlNodeForDoc:node->doc elementName:@"SaveDeviceList" elementNSPrefix:nil]);
	}
	if(self.action != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"action", [tns1_SaveActions_stringFromEnum(self.action) xmlString]);
	}
}
/* elements */
@synthesize authtoken;
@synthesize SaveDeviceList;
@synthesize action;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SaveDeviceInfoRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SaveDeviceInfoRequest *newObject = [[tns1_SaveDeviceInfoRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "SaveDeviceList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_DeviceList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.SaveDeviceList = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "action")) {
				
				tns1_SaveActions enumRepresentation = tns1_SaveActions_enumFromString(elementString);
				self.action = enumRepresentation;
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SaveDeviceInfoResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SaveDeviceInfoResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SaveDeviceInfoResponse *newObject = [[tns1_SaveDeviceInfoResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SaveNewDomainResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SaveNewDomainResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SaveNewDomainResponse *newObject = [[tns1_SaveNewDomainResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SaveNewDomainRequest
- (id)init
{
	if((self = [super init])) {
		authToken = 0;
		AccountId = 0;
		Revision = 0;
		DomainKeyPair = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authToken != nil) [authToken release];
	if(AccountId != nil) [AccountId release];
	if(Revision != nil) [Revision release];
	if(DomainKeyPair != nil) [DomainKeyPair release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authToken != 0) {
		xmlAddChild(node, [self.authToken xmlNodeForDoc:node->doc elementName:@"authToken" elementNSPrefix:nil]);
	}
	if(self.AccountId != 0) {
		xmlAddChild(node, [self.AccountId xmlNodeForDoc:node->doc elementName:@"AccountId" elementNSPrefix:nil]);
	}
	if(self.Revision != 0) {
		xmlAddChild(node, [self.Revision xmlNodeForDoc:node->doc elementName:@"Revision" elementNSPrefix:nil]);
	}
	if(self.DomainKeyPair != 0) {
		xmlAddChild(node, [self.DomainKeyPair xmlNodeForDoc:node->doc elementName:@"DomainKeyPair" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authToken;
@synthesize AccountId;
@synthesize Revision;
@synthesize DomainKeyPair;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SaveNewDomainRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SaveNewDomainRequest *newObject = [[tns1_SaveNewDomainRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authToken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authToken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AccountId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.AccountId = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Revision")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Revision = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "DomainKeyPair")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.DomainKeyPair = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_DeviceLeftDomainResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_DeviceLeftDomainResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_DeviceLeftDomainResponse *newObject = [[tns1_DeviceLeftDomainResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_DeviceLeftDomainRequest
- (id)init
{
	if((self = [super init])) {
		Authtoken = 0;
		DeviceKey = 0;
		ClientId = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(Authtoken != nil) [Authtoken release];
	if(DeviceKey != nil) [DeviceKey release];
	if(ClientId != nil) [ClientId release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.Authtoken != 0) {
		xmlAddChild(node, [self.Authtoken xmlNodeForDoc:node->doc elementName:@"Authtoken" elementNSPrefix:nil]);
	}
	if(self.DeviceKey != 0) {
		xmlAddChild(node, [self.DeviceKey xmlNodeForDoc:node->doc elementName:@"DeviceKey" elementNSPrefix:nil]);
	}
	if(self.ClientId != 0) {
		xmlAddChild(node, [self.ClientId xmlNodeForDoc:node->doc elementName:@"ClientId" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize Authtoken;
@synthesize DeviceKey;
@synthesize ClientId;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_DeviceLeftDomainRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_DeviceLeftDomainRequest *newObject = [[tns1_DeviceLeftDomainRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Authtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "DeviceKey")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.DeviceKey = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ClientId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ClientId = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_DeviceCanJoinDomainResponse
- (id)init
{
	if((self = [super init])) {
		AccountId = 0;
		DomainKeyPair = 0;
		Revision = 0;
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(AccountId != nil) [AccountId release];
	if(DomainKeyPair != nil) [DomainKeyPair release];
	if(Revision != nil) [Revision release];
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.AccountId != 0) {
		xmlAddChild(node, [self.AccountId xmlNodeForDoc:node->doc elementName:@"AccountId" elementNSPrefix:nil]);
	}
	if(self.DomainKeyPair != 0) {
		xmlAddChild(node, [self.DomainKeyPair xmlNodeForDoc:node->doc elementName:@"DomainKeyPair" elementNSPrefix:nil]);
	}
	if(self.Revision != 0) {
		xmlAddChild(node, [self.Revision xmlNodeForDoc:node->doc elementName:@"Revision" elementNSPrefix:nil]);
	}
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize AccountId;
@synthesize DomainKeyPair;
@synthesize Revision;
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_DeviceCanJoinDomainResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_DeviceCanJoinDomainResponse *newObject = [[tns1_DeviceCanJoinDomainResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AccountId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.AccountId = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "DomainKeyPair")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.DomainKeyPair = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Revision")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Revision = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_DeviceCanJoinDomainRequest
- (id)init
{
	if((self = [super init])) {
		authToken = 0;
		DeviceNickname = 0;
		DevicePlatform = 0;
		DeviceKey = 0;
		ClientId = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authToken != nil) [authToken release];
	if(DeviceNickname != nil) [DeviceNickname release];
	if(DevicePlatform != nil) [DevicePlatform release];
	if(DeviceKey != nil) [DeviceKey release];
	if(ClientId != nil) [ClientId release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authToken != 0) {
		xmlAddChild(node, [self.authToken xmlNodeForDoc:node->doc elementName:@"authToken" elementNSPrefix:nil]);
	}
	if(self.DeviceNickname != 0) {
		xmlAddChild(node, [self.DeviceNickname xmlNodeForDoc:node->doc elementName:@"DeviceNickname" elementNSPrefix:nil]);
	}
	if(self.DevicePlatform != 0) {
		xmlAddChild(node, [self.DevicePlatform xmlNodeForDoc:node->doc elementName:@"DevicePlatform" elementNSPrefix:nil]);
	}
	if(self.DeviceKey != 0) {
		xmlAddChild(node, [self.DeviceKey xmlNodeForDoc:node->doc elementName:@"DeviceKey" elementNSPrefix:nil]);
	}
	if(self.ClientId != 0) {
		xmlAddChild(node, [self.ClientId xmlNodeForDoc:node->doc elementName:@"ClientId" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authToken;
@synthesize DeviceNickname;
@synthesize DevicePlatform;
@synthesize DeviceKey;
@synthesize ClientId;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_DeviceCanJoinDomainRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_DeviceCanJoinDomainRequest *newObject = [[tns1_DeviceCanJoinDomainRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authToken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authToken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "DeviceNickname")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.DeviceNickname = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "DevicePlatform")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.DevicePlatform = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "DeviceKey")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.DeviceKey = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ClientId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ClientId = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_GetLicensableStatusResponse
- (id)init
{
	if((self = [super init])) {
		AccountId = 0;
		Revision = 0;
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(AccountId != nil) [AccountId release];
	if(Revision != nil) [Revision release];
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.AccountId != 0) {
		xmlAddChild(node, [self.AccountId xmlNodeForDoc:node->doc elementName:@"AccountId" elementNSPrefix:nil]);
	}
	if(self.Revision != 0) {
		xmlAddChild(node, [self.Revision xmlNodeForDoc:node->doc elementName:@"Revision" elementNSPrefix:nil]);
	}
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize AccountId;
@synthesize Revision;
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_GetLicensableStatusResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_GetLicensableStatusResponse *newObject = [[tns1_GetLicensableStatusResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AccountId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.AccountId = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Revision")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Revision = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_GetLicensableStatusRequest
- (id)init
{
	if((self = [super init])) {
		authToken = 0;
		KeyId = 0;
		suppliedIdentifier = 0;
		suppliedIdentifierType = 0;
		TransactionId = 0;
		ClientId = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authToken != nil) [authToken release];
	if(KeyId != nil) [KeyId release];
	if(suppliedIdentifier != nil) [suppliedIdentifier release];
	if(suppliedIdentifierType != nil) [suppliedIdentifierType release];
	if(TransactionId != nil) [TransactionId release];
	if(ClientId != nil) [ClientId release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authToken != 0) {
		xmlAddChild(node, [self.authToken xmlNodeForDoc:node->doc elementName:@"authToken" elementNSPrefix:nil]);
	}
	if(self.KeyId != 0) {
		xmlAddChild(node, [self.KeyId xmlNodeForDoc:node->doc elementName:@"KeyId" elementNSPrefix:nil]);
	}
	if(self.suppliedIdentifier != 0) {
		xmlAddChild(node, [self.suppliedIdentifier xmlNodeForDoc:node->doc elementName:@"suppliedIdentifier" elementNSPrefix:nil]);
	}
	if(self.suppliedIdentifierType != 0) {
		xmlAddChild(node, [self.suppliedIdentifierType xmlNodeForDoc:node->doc elementName:@"suppliedIdentifierType" elementNSPrefix:nil]);
	}
	if(self.TransactionId != 0) {
		xmlAddChild(node, [self.TransactionId xmlNodeForDoc:node->doc elementName:@"TransactionId" elementNSPrefix:nil]);
	}
	if(self.ClientId != 0) {
		xmlAddChild(node, [self.ClientId xmlNodeForDoc:node->doc elementName:@"ClientId" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authToken;
@synthesize KeyId;
@synthesize suppliedIdentifier;
@synthesize suppliedIdentifierType;
@synthesize TransactionId;
@synthesize ClientId;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_GetLicensableStatusRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_GetLicensableStatusRequest *newObject = [[tns1_GetLicensableStatusRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authToken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authToken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "KeyId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.KeyId = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "suppliedIdentifier")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.suppliedIdentifier = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "suppliedIdentifierType")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.suppliedIdentifierType = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "TransactionId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.TransactionId = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ClientId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ClientId = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AcknowledgeLicenseResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AcknowledgeLicenseResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AcknowledgeLicenseResponse *newObject = [[tns1_AcknowledgeLicenseResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AcknowledgeLicenseRequest
- (id)init
{
	if((self = [super init])) {
		TransactionId = 0;
		ClientId = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(TransactionId != nil) [TransactionId release];
	if(ClientId != nil) [ClientId release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.TransactionId != 0) {
		xmlAddChild(node, [self.TransactionId xmlNodeForDoc:node->doc elementName:@"TransactionId" elementNSPrefix:nil]);
	}
	if(self.ClientId != 0) {
		xmlAddChild(node, [self.ClientId xmlNodeForDoc:node->doc elementName:@"ClientId" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize TransactionId;
@synthesize ClientId;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AcknowledgeLicenseRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AcknowledgeLicenseRequest *newObject = [[tns1_AcknowledgeLicenseRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "TransactionId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.TransactionId = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ClientId")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ClientId = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ValidateScreenNameRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
		screenName = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	if(screenName != nil) [screenName release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
	if(self.screenName != 0) {
		xmlAddChild(node, [self.screenName xmlNodeForDoc:node->doc elementName:@"screenName" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
@synthesize screenName;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ValidateScreenNameRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ValidateScreenNameRequest *newObject = [[tns1_ValidateScreenNameRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "screenName")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.screenName = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ValidateScreenNameResponse
- (id)init
{
	if((self = [super init])) {
		result = 0;
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(result != nil) [result release];
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.result != 0) {
		xmlAddChild(node, [self.result xmlNodeForDoc:node->doc elementName:@"result" elementNSPrefix:nil]);
	}
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize result;
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ValidateScreenNameResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ValidateScreenNameResponse *newObject = [[tns1_ValidateScreenNameResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "result")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.result = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ValidateUserKeyRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
		userKey = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	if(userKey != nil) [userKey release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
	if(self.userKey != 0) {
		xmlAddChild(node, [self.userKey xmlNodeForDoc:node->doc elementName:@"userKey" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
@synthesize userKey;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ValidateUserKeyRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ValidateUserKeyRequest *newObject = [[tns1_ValidateUserKeyRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "userKey")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.userKey = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ValidateUserKeyResponse
- (id)init
{
	if((self = [super init])) {
		result = 0;
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(result != nil) [result release];
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.result != 0) {
		xmlAddChild(node, [self.result xmlNodeForDoc:node->doc elementName:@"result" elementNSPrefix:nil]);
	}
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize result;
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ValidateUserKeyResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ValidateUserKeyResponse *newObject = [[tns1_ValidateUserKeyResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "result")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.result = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_DeleteBookShelfEntryRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
		BookShelfEntryList = 0;
		cascade = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	if(BookShelfEntryList != nil) [BookShelfEntryList release];
	if(cascade != nil) [cascade release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
	if(self.BookShelfEntryList != 0) {
		xmlAddChild(node, [self.BookShelfEntryList xmlNodeForDoc:node->doc elementName:@"BookShelfEntryList" elementNSPrefix:nil]);
	}
	if(self.cascade != 0) {
		xmlAddChild(node, [self.cascade xmlNodeForDoc:node->doc elementName:@"cascade" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
@synthesize BookShelfEntryList;
@synthesize cascade;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_DeleteBookShelfEntryRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_DeleteBookShelfEntryRequest *newObject = [[tns1_DeleteBookShelfEntryRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "BookShelfEntryList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_BookshelfEntryList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.BookShelfEntryList = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "cascade")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.cascade = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_DeleteBookShelfEntryResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_DeleteBookShelfEntryResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_DeleteBookShelfEntryResponse *newObject = [[tns1_DeleteBookShelfEntryResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_GetLastPageLocationRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_GetLastPageLocationRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_GetLastPageLocationRequest *newObject = [[tns1_GetLastPageLocationRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_GetLastPageLocationResponse
- (id)init
{
	if((self = [super init])) {
		ProfileBookshelfEntryList = 0;
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(ProfileBookshelfEntryList != nil) [ProfileBookshelfEntryList release];
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.ProfileBookshelfEntryList != 0) {
		xmlAddChild(node, [self.ProfileBookshelfEntryList xmlNodeForDoc:node->doc elementName:@"ProfileBookshelfEntryList" elementNSPrefix:nil]);
	}
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize ProfileBookshelfEntryList;
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_GetLastPageLocationResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_GetLastPageLocationResponse *newObject = [[tns1_GetLastPageLocationResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ProfileBookshelfEntryList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ProfileBookshelfEntryList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ProfileBookshelfEntryList = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SaveLastPageLocationRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
		ProfileBookshelfEntryList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	if(ProfileBookshelfEntryList != nil) [ProfileBookshelfEntryList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
	if(self.ProfileBookshelfEntryList != 0) {
		xmlAddChild(node, [self.ProfileBookshelfEntryList xmlNodeForDoc:node->doc elementName:@"ProfileBookshelfEntryList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
@synthesize ProfileBookshelfEntryList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SaveLastPageLocationRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SaveLastPageLocationRequest *newObject = [[tns1_SaveLastPageLocationRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ProfileBookshelfEntryList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ProfileBookshelfEntryList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ProfileBookshelfEntryList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SaveLastPageLocationResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SaveLastPageLocationResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SaveLastPageLocationResponse *newObject = [[tns1_SaveLastPageLocationResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListFavoriteTypesRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListFavoriteTypesRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListFavoriteTypesRequest *newObject = [[tns1_ListFavoriteTypesRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListFavoriteTypesResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
		FavoriteTypesList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	if(FavoriteTypesList != nil) [FavoriteTypesList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
	if(self.FavoriteTypesList != 0) {
		xmlAddChild(node, [self.FavoriteTypesList xmlNodeForDoc:node->doc elementName:@"FavoriteTypesList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
@synthesize FavoriteTypesList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListFavoriteTypesResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListFavoriteTypesResponse *newObject = [[tns1_ListFavoriteTypesResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "FavoriteTypesList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_FavoriteTypesList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.FavoriteTypesList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SaveUserSettingsRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
		settingsList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	if(settingsList != nil) [settingsList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
	if(self.settingsList != 0) {
		xmlAddChild(node, [self.settingsList xmlNodeForDoc:node->doc elementName:@"settingsList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
@synthesize settingsList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SaveUserSettingsRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SaveUserSettingsRequest *newObject = [[tns1_SaveUserSettingsRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "settingsList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_SettingsList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.settingsList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SaveUserSettingsResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
		settingStatusList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	if(settingStatusList != nil) [settingStatusList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
	if(self.settingStatusList != 0) {
		xmlAddChild(node, [self.settingStatusList xmlNodeForDoc:node->doc elementName:@"settingStatusList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
@synthesize settingStatusList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SaveUserSettingsResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SaveUserSettingsResponse *newObject = [[tns1_SaveUserSettingsResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "settingStatusList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_SettingStatusList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.settingStatusList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListUserSettingsRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListUserSettingsRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListUserSettingsRequest *newObject = [[tns1_ListUserSettingsRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListUserSettingsResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
		settingsList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	if(settingsList != nil) [settingsList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
	if(self.settingsList != 0) {
		xmlAddChild(node, [self.settingsList xmlNodeForDoc:node->doc elementName:@"settingsList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
@synthesize settingsList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListUserSettingsResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListUserSettingsResponse *newObject = [[tns1_ListUserSettingsResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "settingsList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_SettingsList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.settingsList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SetAccountAutoAssignRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
		AutoAssignProfilesList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	if(AutoAssignProfilesList != nil) [AutoAssignProfilesList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
	if(self.AutoAssignProfilesList != 0) {
		xmlAddChild(node, [self.AutoAssignProfilesList xmlNodeForDoc:node->doc elementName:@"AutoAssignProfilesList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
@synthesize AutoAssignProfilesList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SetAccountAutoAssignRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SetAccountAutoAssignRequest *newObject = [[tns1_SetAccountAutoAssignRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "AutoAssignProfilesList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AutoAssignProfilesList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.AutoAssignProfilesList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SetAccountAutoAssignResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SetAccountAutoAssignResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SetAccountAutoAssignResponse *newObject = [[tns1_SetAccountAutoAssignResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SetAccountPasswordRequiredRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
		passwordRequired = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	if(passwordRequired != nil) [passwordRequired release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
	if(self.passwordRequired != 0) {
		xmlAddChild(node, [self.passwordRequired xmlNodeForDoc:node->doc elementName:@"passwordRequired" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
@synthesize passwordRequired;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SetAccountPasswordRequiredRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SetAccountPasswordRequiredRequest *newObject = [[tns1_SetAccountPasswordRequiredRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "passwordRequired")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.passwordRequired = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SetAccountPasswordRequiredResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SetAccountPasswordRequiredResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SetAccountPasswordRequiredResponse *newObject = [[tns1_SetAccountPasswordRequiredResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListReadBooksRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListReadBooksRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListReadBooksRequest *newObject = [[tns1_ListReadBooksRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListReadBooksResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
		ReadBooksList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	if(ReadBooksList != nil) [ReadBooksList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
	if(self.ReadBooksList != 0) {
		xmlAddChild(node, [self.ReadBooksList xmlNodeForDoc:node->doc elementName:@"ReadBooksList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
@synthesize ReadBooksList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListReadBooksResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListReadBooksResponse *newObject = [[tns1_ListReadBooksResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ReadBooksList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ReadBooksList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ReadBooksList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListLastNProfileReadBooksRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
		lastBooksCount = 0;
		uniqueBooks = 0;
		LastNRequestReadBooksProfilesList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	if(lastBooksCount != nil) [lastBooksCount release];
	if(uniqueBooks != nil) [uniqueBooks release];
	if(LastNRequestReadBooksProfilesList != nil) [LastNRequestReadBooksProfilesList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
	if(self.lastBooksCount != 0) {
		xmlAddChild(node, [self.lastBooksCount xmlNodeForDoc:node->doc elementName:@"lastBooksCount" elementNSPrefix:nil]);
	}
	if(self.uniqueBooks != 0) {
		xmlAddChild(node, [self.uniqueBooks xmlNodeForDoc:node->doc elementName:@"uniqueBooks" elementNSPrefix:nil]);
	}
	if(self.LastNRequestReadBooksProfilesList != 0) {
		xmlAddChild(node, [self.LastNRequestReadBooksProfilesList xmlNodeForDoc:node->doc elementName:@"LastNRequestReadBooksProfilesList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
@synthesize lastBooksCount;
@synthesize uniqueBooks;
@synthesize LastNRequestReadBooksProfilesList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListLastNProfileReadBooksRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListLastNProfileReadBooksRequest *newObject = [[tns1_ListLastNProfileReadBooksRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lastBooksCount")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lastBooksCount = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "uniqueBooks")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.uniqueBooks = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "LastNRequestReadBooksProfilesList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_LastNRequestReadBooksProfilesList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.LastNRequestReadBooksProfilesList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListLastNProfileReadBooksResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
		LastNResponseReadBooksProfilesList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	if(LastNResponseReadBooksProfilesList != nil) [LastNResponseReadBooksProfilesList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
	if(self.LastNResponseReadBooksProfilesList != 0) {
		xmlAddChild(node, [self.LastNResponseReadBooksProfilesList xmlNodeForDoc:node->doc elementName:@"LastNResponseReadBooksProfilesList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
@synthesize LastNResponseReadBooksProfilesList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListLastNProfileReadBooksResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListLastNProfileReadBooksResponse *newObject = [[tns1_ListLastNProfileReadBooksResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "LastNResponseReadBooksProfilesList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_LastNResponseReadBooksProfilesList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.LastNResponseReadBooksProfilesList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListLastNWordsRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
		lastWordsCount = 0;
		startDate = 0;
		endDate = 0;
		LastNRequestWordsList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	if(lastWordsCount != nil) [lastWordsCount release];
	if(startDate != nil) [startDate release];
	if(endDate != nil) [endDate release];
	if(LastNRequestWordsList != nil) [LastNRequestWordsList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
	if(self.lastWordsCount != 0) {
		xmlAddChild(node, [self.lastWordsCount xmlNodeForDoc:node->doc elementName:@"lastWordsCount" elementNSPrefix:nil]);
	}
	if(self.startDate != 0) {
		xmlAddChild(node, [self.startDate xmlNodeForDoc:node->doc elementName:@"startDate" elementNSPrefix:nil]);
	}
	if(self.endDate != 0) {
		xmlAddChild(node, [self.endDate xmlNodeForDoc:node->doc elementName:@"endDate" elementNSPrefix:nil]);
	}
	if(self.LastNRequestWordsList != 0) {
		xmlAddChild(node, [self.LastNRequestWordsList xmlNodeForDoc:node->doc elementName:@"LastNRequestWordsList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
@synthesize lastWordsCount;
@synthesize startDate;
@synthesize endDate;
@synthesize LastNRequestWordsList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListLastNWordsRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListLastNWordsRequest *newObject = [[tns1_ListLastNWordsRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lastWordsCount")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lastWordsCount = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "startDate")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.startDate = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "endDate")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.endDate = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "LastNRequestWordsList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_LastNRequestWordsList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.LastNRequestWordsList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListLastNWordsResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
		LastNResponseWordsList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	if(LastNResponseWordsList != nil) [LastNResponseWordsList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
	if(self.LastNResponseWordsList != 0) {
		xmlAddChild(node, [self.LastNResponseWordsList xmlNodeForDoc:node->doc elementName:@"LastNResponseWordsList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
@synthesize LastNResponseWordsList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListLastNWordsResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListLastNWordsResponse *newObject = [[tns1_ListLastNWordsResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "LastNResponseWordsList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_LastNResponseWordsList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.LastNResponseWordsList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_RemoveOrderRequest
- (id)init
{
	if((self = [super init])) {
		authtoken = 0;
		userKey = 0;
		orderID = 0;
		contentidentifier = 0;
		contentIdentifierType = 0;
		DRMQualifier = 0;
		Format = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authtoken != nil) [authtoken release];
	if(userKey != nil) [userKey release];
	if(orderID != nil) [orderID release];
	if(contentidentifier != nil) [contentidentifier release];
	if(Format != nil) [Format release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authtoken != 0) {
		xmlAddChild(node, [self.authtoken xmlNodeForDoc:node->doc elementName:@"authtoken" elementNSPrefix:nil]);
	}
	if(self.userKey != 0) {
		xmlAddChild(node, [self.userKey xmlNodeForDoc:node->doc elementName:@"userKey" elementNSPrefix:nil]);
	}
	if(self.orderID != 0) {
		xmlAddChild(node, [self.orderID xmlNodeForDoc:node->doc elementName:@"orderID" elementNSPrefix:nil]);
	}
	if(self.contentidentifier != 0) {
		xmlAddChild(node, [self.contentidentifier xmlNodeForDoc:node->doc elementName:@"contentidentifier" elementNSPrefix:nil]);
	}
	if(self.contentIdentifierType != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"contentIdentifierType", [tns1_ContentIdentifierTypes_stringFromEnum(self.contentIdentifierType) xmlString]);
	}
	if(self.DRMQualifier != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"DRMQualifier", [tns1_drmqualifiers_stringFromEnum(self.DRMQualifier) xmlString]);
	}
	if(self.Format != 0) {
		xmlAddChild(node, [self.Format xmlNodeForDoc:node->doc elementName:@"Format" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authtoken;
@synthesize userKey;
@synthesize orderID;
@synthesize contentidentifier;
@synthesize contentIdentifierType;
@synthesize DRMQualifier;
@synthesize Format;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_RemoveOrderRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_RemoveOrderRequest *newObject = [[tns1_RemoveOrderRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "userKey")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.userKey = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "orderID")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.orderID = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentidentifier")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.contentidentifier = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentIdentifierType")) {
				
				tns1_ContentIdentifierTypes enumRepresentation = tns1_ContentIdentifierTypes_enumFromString(elementString);
				self.contentIdentifierType = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "DRMQualifier")) {
				
				tns1_drmqualifiers enumRepresentation = tns1_drmqualifiers_enumFromString(elementString);
				self.DRMQualifier = enumRepresentation;
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Format")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Format = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_RemoveOrderResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_RemoveOrderResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_RemoveOrderResponse *newObject = [[tns1_RemoveOrderResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SaveUserCSRNotesRequest
- (id)init
{
	if((self = [super init])) {
		CSRtoken = 0;
		userKey = 0;
		noteText = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(CSRtoken != nil) [CSRtoken release];
	if(userKey != nil) [userKey release];
	if(noteText != nil) [noteText release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.CSRtoken != 0) {
		xmlAddChild(node, [self.CSRtoken xmlNodeForDoc:node->doc elementName:@"CSRtoken" elementNSPrefix:nil]);
	}
	if(self.userKey != 0) {
		xmlAddChild(node, [self.userKey xmlNodeForDoc:node->doc elementName:@"userKey" elementNSPrefix:nil]);
	}
	if(self.noteText != 0) {
		xmlAddChild(node, [self.noteText xmlNodeForDoc:node->doc elementName:@"noteText" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize CSRtoken;
@synthesize userKey;
@synthesize noteText;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SaveUserCSRNotesRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SaveUserCSRNotesRequest *newObject = [[tns1_SaveUserCSRNotesRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "CSRtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.CSRtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "userKey")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.userKey = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "noteText")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.noteText = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SaveUserCSRNotesResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SaveUserCSRNotesResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SaveUserCSRNotesResponse *newObject = [[tns1_SaveUserCSRNotesResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListUserCSRNotesRequest
- (id)init
{
	if((self = [super init])) {
		CSRtoken = 0;
		userKey = 0;
		lastNNotes = 0;
		startDate = 0;
		endDate = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(CSRtoken != nil) [CSRtoken release];
	if(userKey != nil) [userKey release];
	if(lastNNotes != nil) [lastNNotes release];
	if(startDate != nil) [startDate release];
	if(endDate != nil) [endDate release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.CSRtoken != 0) {
		xmlAddChild(node, [self.CSRtoken xmlNodeForDoc:node->doc elementName:@"CSRtoken" elementNSPrefix:nil]);
	}
	if(self.userKey != 0) {
		xmlAddChild(node, [self.userKey xmlNodeForDoc:node->doc elementName:@"userKey" elementNSPrefix:nil]);
	}
	if(self.lastNNotes != 0) {
		xmlAddChild(node, [self.lastNNotes xmlNodeForDoc:node->doc elementName:@"lastNNotes" elementNSPrefix:nil]);
	}
	if(self.startDate != 0) {
		xmlAddChild(node, [self.startDate xmlNodeForDoc:node->doc elementName:@"startDate" elementNSPrefix:nil]);
	}
	if(self.endDate != 0) {
		xmlAddChild(node, [self.endDate xmlNodeForDoc:node->doc elementName:@"endDate" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize CSRtoken;
@synthesize userKey;
@synthesize lastNNotes;
@synthesize startDate;
@synthesize endDate;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListUserCSRNotesRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListUserCSRNotesRequest *newObject = [[tns1_ListUserCSRNotesRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "CSRtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.CSRtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "userKey")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.userKey = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lastNNotes")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lastNNotes = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "startDate")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.startDate = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "endDate")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.endDate = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListUserCSRNotesResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
		notesList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	if(notesList != nil) [notesList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
	if(self.notesList != 0) {
		xmlAddChild(node, [self.notesList xmlNodeForDoc:node->doc elementName:@"notesList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
@synthesize notesList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListUserCSRNotesResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListUserCSRNotesResponse *newObject = [[tns1_ListUserCSRNotesResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "notesList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_NotesList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.notesList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_GetKeyIdRequest
- (id)init
{
	if((self = [super init])) {
		contentidentifier = 0;
		contentIdentifierType = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(contentidentifier != nil) [contentidentifier release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.contentidentifier != 0) {
		xmlAddChild(node, [self.contentidentifier xmlNodeForDoc:node->doc elementName:@"contentidentifier" elementNSPrefix:nil]);
	}
	if(self.contentIdentifierType != 0) {
		xmlNewChild(node, NULL, (const xmlChar*)"contentIdentifierType", [tns1_ContentIdentifierTypes_stringFromEnum(self.contentIdentifierType) xmlString]);
	}
}
/* elements */
@synthesize contentidentifier;
@synthesize contentIdentifierType;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_GetKeyIdRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_GetKeyIdRequest *newObject = [[tns1_GetKeyIdRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentidentifier")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.contentidentifier = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "contentIdentifierType")) {
				
				tns1_ContentIdentifierTypes enumRepresentation = tns1_ContentIdentifierTypes_enumFromString(elementString);
				self.contentIdentifierType = enumRepresentation;
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_GetKeyIdResponse
- (id)init
{
	if((self = [super init])) {
		guid = 0;
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(guid != nil) [guid release];
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.guid != 0) {
		xmlAddChild(node, [self.guid xmlNodeForDoc:node->doc elementName:@"guid" elementNSPrefix:nil]);
	}
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize guid;
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_GetKeyIdResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_GetKeyIdResponse *newObject = [[tns1_GetKeyIdResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "guid")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.guid = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SaveDefaultBooksRequest
- (id)init
{
	if((self = [super init])) {
		CSRtoken = 0;
		BooksList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(CSRtoken != nil) [CSRtoken release];
	if(BooksList != nil) [BooksList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.CSRtoken != 0) {
		xmlAddChild(node, [self.CSRtoken xmlNodeForDoc:node->doc elementName:@"CSRtoken" elementNSPrefix:nil]);
	}
	if(self.BooksList != 0) {
		xmlAddChild(node, [self.BooksList xmlNodeForDoc:node->doc elementName:@"BooksList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize CSRtoken;
@synthesize BooksList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SaveDefaultBooksRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SaveDefaultBooksRequest *newObject = [[tns1_SaveDefaultBooksRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "CSRtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.CSRtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "BooksList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_DefaultBooksList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.BooksList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SaveDefaultBooksResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SaveDefaultBooksResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SaveDefaultBooksResponse *newObject = [[tns1_SaveDefaultBooksResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListDefaultBooksRequest
- (id)init
{
	if((self = [super init])) {
		authToken = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authToken != nil) [authToken release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authToken != 0) {
		xmlAddChild(node, [self.authToken xmlNodeForDoc:node->doc elementName:@"authToken" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authToken;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListDefaultBooksRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListDefaultBooksRequest *newObject = [[tns1_ListDefaultBooksRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authToken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authToken = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListDefaultBooksResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
		BooksList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	if(BooksList != nil) [BooksList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
	if(self.BooksList != 0) {
		xmlAddChild(node, [self.BooksList xmlNodeForDoc:node->doc elementName:@"BooksList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
@synthesize BooksList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListDefaultBooksResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListDefaultBooksResponse *newObject = [[tns1_ListDefaultBooksResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "BooksList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_DefaultBooksList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.BooksList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_RemoveDefaultBooksRequest
- (id)init
{
	if((self = [super init])) {
		CSRtoken = 0;
		BooksList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(CSRtoken != nil) [CSRtoken release];
	if(BooksList != nil) [BooksList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.CSRtoken != 0) {
		xmlAddChild(node, [self.CSRtoken xmlNodeForDoc:node->doc elementName:@"CSRtoken" elementNSPrefix:nil]);
	}
	if(self.BooksList != 0) {
		xmlAddChild(node, [self.BooksList xmlNodeForDoc:node->doc elementName:@"BooksList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize CSRtoken;
@synthesize BooksList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_RemoveDefaultBooksRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_RemoveDefaultBooksRequest *newObject = [[tns1_RemoveDefaultBooksRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "CSRtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.CSRtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "BooksList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_DefaultBooksList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.BooksList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_RemoveDefaultBooksResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_RemoveDefaultBooksResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_RemoveDefaultBooksResponse *newObject = [[tns1_RemoveDefaultBooksResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AssignBooksToAllUsersRequest
- (id)init
{
	if((self = [super init])) {
		CSRtoken = 0;
		UsersList = 0;
		BooksList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(CSRtoken != nil) [CSRtoken release];
	if(UsersList != nil) [UsersList release];
	if(BooksList != nil) [BooksList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.CSRtoken != 0) {
		xmlAddChild(node, [self.CSRtoken xmlNodeForDoc:node->doc elementName:@"CSRtoken" elementNSPrefix:nil]);
	}
	if(self.UsersList != 0) {
		xmlAddChild(node, [self.UsersList xmlNodeForDoc:node->doc elementName:@"UsersList" elementNSPrefix:nil]);
	}
	if(self.BooksList != 0) {
		xmlAddChild(node, [self.BooksList xmlNodeForDoc:node->doc elementName:@"BooksList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize CSRtoken;
@synthesize UsersList;
@synthesize BooksList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AssignBooksToAllUsersRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AssignBooksToAllUsersRequest *newObject = [[tns1_AssignBooksToAllUsersRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "CSRtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.CSRtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "UsersList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AssignBooksToAllUsersList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.UsersList = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "BooksList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_AssignBooksToAllUsersBooksList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.BooksList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_AssignBooksToAllUsersResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_AssignBooksToAllUsersResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_AssignBooksToAllUsersResponse *newObject = [[tns1_AssignBooksToAllUsersResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SetLoggingLevelRequest
- (id)init
{
	if((self = [super init])) {
		CSRtoken = 0;
		Level = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(CSRtoken != nil) [CSRtoken release];
	if(Level != nil) [Level release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.CSRtoken != 0) {
		xmlAddChild(node, [self.CSRtoken xmlNodeForDoc:node->doc elementName:@"CSRtoken" elementNSPrefix:nil]);
	}
	if(self.Level != 0) {
		xmlAddChild(node, [self.Level xmlNodeForDoc:node->doc elementName:@"Level" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize CSRtoken;
@synthesize Level;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SetLoggingLevelRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SetLoggingLevelRequest *newObject = [[tns1_SetLoggingLevelRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "CSRtoken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.CSRtoken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Level")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.Level = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SetLoggingLevelResponse
- (id)init
{
	if((self = [super init])) {
		statusmessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusmessage != nil) [statusmessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusmessage != 0) {
		xmlAddChild(node, [self.statusmessage xmlNodeForDoc:node->doc elementName:@"statusmessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusmessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SetLoggingLevelResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SetLoggingLevelResponse *newObject = [[tns1_SetLoggingLevelResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusmessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusmessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_HealthCheckRequest
- (id)init
{
	if((self = [super init])) {
	}
	
	return self;
}
- (void)dealloc
{
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
}
/* elements */
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_HealthCheckRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_HealthCheckRequest *newObject = [[tns1_HealthCheckRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_EndpointsList
- (id)init
{
	if((self = [super init])) {
		Endpoint = [[NSMutableArray alloc] init];
	}
	
	return self;
}
- (void)dealloc
{
	if(Endpoint != nil) [Endpoint release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.Endpoint != 0) {
		for(NSString * child in self.Endpoint) {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"Endpoint" elementNSPrefix:nil]);
		}
	}
}
/* elements */
@synthesize Endpoint;
- (void)addEndpoint:(NSString *)toAdd
{
	if(toAdd != nil) [Endpoint addObject:toAdd];
}
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_EndpointsList *)deserializeNode:(xmlNodePtr)cur
{
	tns1_EndpointsList *newObject = [[tns1_EndpointsList new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "Endpoint")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    if(newChild != nil) [self.Endpoint addObject:newChild];
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_DBSchemaError
- (id)init
{
	if((self = [super init])) {
		lastDBModify = 0;
		errorList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(lastDBModify != nil) [lastDBModify release];
	if(errorList != nil) [errorList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.lastDBModify != 0) {
		xmlAddChild(node, [self.lastDBModify xmlNodeForDoc:node->doc elementName:@"lastDBModify" elementNSPrefix:nil]);
	}
	if(self.errorList != 0) {
		xmlAddChild(node, [self.errorList xmlNodeForDoc:node->doc elementName:@"errorList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize lastDBModify;
@synthesize errorList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_DBSchemaError *)deserializeNode:(xmlNodePtr)cur
{
	tns1_DBSchemaError *newObject = [[tns1_DBSchemaError new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "lastDBModify")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSDate class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.lastDBModify = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "errorList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_DBSchemaErrorList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.errorList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_HealthCheckResponse
- (id)init
{
	if((self = [super init])) {
		statusCode = 0;
		datapipe = 0;
		gatewayDatabase = 0;
		activityLogDatabase = 0;
		endpoints = 0;
		currentDBVersion = 0;
		LAversion = 0;
		DBSchemaErrors = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusCode != nil) [statusCode release];
	if(datapipe != nil) [datapipe release];
	if(gatewayDatabase != nil) [gatewayDatabase release];
	if(activityLogDatabase != nil) [activityLogDatabase release];
	if(endpoints != nil) [endpoints release];
	if(currentDBVersion != nil) [currentDBVersion release];
	if(LAversion != nil) [LAversion release];
	if(DBSchemaErrors != nil) [DBSchemaErrors release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusCode != 0) {
		xmlAddChild(node, [self.statusCode xmlNodeForDoc:node->doc elementName:@"statusCode" elementNSPrefix:nil]);
	}
	if(self.datapipe != 0) {
		xmlAddChild(node, [self.datapipe xmlNodeForDoc:node->doc elementName:@"datapipe" elementNSPrefix:nil]);
	}
	if(self.gatewayDatabase != 0) {
		xmlAddChild(node, [self.gatewayDatabase xmlNodeForDoc:node->doc elementName:@"gatewayDatabase" elementNSPrefix:nil]);
	}
	if(self.activityLogDatabase != 0) {
		xmlAddChild(node, [self.activityLogDatabase xmlNodeForDoc:node->doc elementName:@"activityLogDatabase" elementNSPrefix:nil]);
	}
	if(self.endpoints != 0) {
		xmlAddChild(node, [self.endpoints xmlNodeForDoc:node->doc elementName:@"endpoints" elementNSPrefix:nil]);
	}
	if(self.currentDBVersion != 0) {
		xmlAddChild(node, [self.currentDBVersion xmlNodeForDoc:node->doc elementName:@"currentDBVersion" elementNSPrefix:nil]);
	}
	if(self.LAversion != 0) {
		xmlAddChild(node, [self.LAversion xmlNodeForDoc:node->doc elementName:@"LAversion" elementNSPrefix:nil]);
	}
	if(self.DBSchemaErrors != 0) {
		xmlAddChild(node, [self.DBSchemaErrors xmlNodeForDoc:node->doc elementName:@"DBSchemaErrors" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusCode;
@synthesize datapipe;
@synthesize gatewayDatabase;
@synthesize activityLogDatabase;
@synthesize endpoints;
@synthesize currentDBVersion;
@synthesize LAversion;
@synthesize DBSchemaErrors;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_HealthCheckResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_HealthCheckResponse *newObject = [[tns1_HealthCheckResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusCode")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusCode = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "datapipe")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.datapipe = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "gatewayDatabase")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.gatewayDatabase = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "activityLogDatabase")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.activityLogDatabase = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "endpoints")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_EndpointsList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.endpoints = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "currentDBVersion")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.currentDBVersion = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "LAversion")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.LAversion = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "DBSchemaErrors")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_DBSchemaError class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.DBSchemaErrors = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_GetVersionRequest
- (id)init
{
	if((self = [super init])) {
	}
	
	return self;
}
- (void)dealloc
{
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
}
/* elements */
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_GetVersionRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_GetVersionRequest *newObject = [[tns1_GetVersionRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_GetVersionResponse
- (id)init
{
	if((self = [super init])) {
		version = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(version != nil) [version release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.version != 0) {
		xmlAddChild(node, [self.version xmlNodeForDoc:node->doc elementName:@"version" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize version;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_GetVersionResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_GetVersionResponse *newObject = [[tns1_GetVersionResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "version")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.version = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListTopRatingsRequest
- (id)init
{
	if((self = [super init])) {
		authToken = 0;
		count = 0;
		topRatingsRequestList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authToken != nil) [authToken release];
	if(count != nil) [count release];
	if(topRatingsRequestList != nil) [topRatingsRequestList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authToken != 0) {
		xmlAddChild(node, [self.authToken xmlNodeForDoc:node->doc elementName:@"authToken" elementNSPrefix:nil]);
	}
	if(self.count != 0) {
		xmlAddChild(node, [self.count xmlNodeForDoc:node->doc elementName:@"count" elementNSPrefix:nil]);
	}
	if(self.topRatingsRequestList != 0) {
		xmlAddChild(node, [self.topRatingsRequestList xmlNodeForDoc:node->doc elementName:@"topRatingsRequestList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authToken;
@synthesize count;
@synthesize topRatingsRequestList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListTopRatingsRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListTopRatingsRequest *newObject = [[tns1_ListTopRatingsRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authToken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authToken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "count")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSNumber class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.count = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "topRatingsRequestList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_TopRatingsRequestList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.topRatingsRequestList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListTopRatingsResponse
- (id)init
{
	if((self = [super init])) {
		statusMessage = 0;
		topRatingsResponseList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusMessage != nil) [statusMessage release];
	if(topRatingsResponseList != nil) [topRatingsResponseList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusMessage != 0) {
		xmlAddChild(node, [self.statusMessage xmlNodeForDoc:node->doc elementName:@"statusMessage" elementNSPrefix:nil]);
	}
	if(self.topRatingsResponseList != 0) {
		xmlAddChild(node, [self.topRatingsResponseList xmlNodeForDoc:node->doc elementName:@"topRatingsResponseList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusMessage;
@synthesize topRatingsResponseList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListTopRatingsResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListTopRatingsResponse *newObject = [[tns1_ListTopRatingsResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusMessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusMessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "topRatingsResponseList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_TopRatingsResponseList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.topRatingsResponseList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SaveRatingsRequest
- (id)init
{
	if((self = [super init])) {
		authToken = 0;
		ratingsList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authToken != nil) [authToken release];
	if(ratingsList != nil) [ratingsList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authToken != 0) {
		xmlAddChild(node, [self.authToken xmlNodeForDoc:node->doc elementName:@"authToken" elementNSPrefix:nil]);
	}
	if(self.ratingsList != 0) {
		xmlAddChild(node, [self.ratingsList xmlNodeForDoc:node->doc elementName:@"ratingsList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authToken;
@synthesize ratingsList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SaveRatingsRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SaveRatingsRequest *newObject = [[tns1_SaveRatingsRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authToken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authToken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ratingsList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_RatingsList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ratingsList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_SaveRatingsResponse
- (id)init
{
	if((self = [super init])) {
		statusMessage = 0;
		ratingsList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusMessage != nil) [statusMessage release];
	if(ratingsList != nil) [ratingsList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusMessage != 0) {
		xmlAddChild(node, [self.statusMessage xmlNodeForDoc:node->doc elementName:@"statusMessage" elementNSPrefix:nil]);
	}
	if(self.ratingsList != 0) {
		xmlAddChild(node, [self.ratingsList xmlNodeForDoc:node->doc elementName:@"ratingsList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusMessage;
@synthesize ratingsList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_SaveRatingsResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_SaveRatingsResponse *newObject = [[tns1_SaveRatingsResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusMessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusMessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ratingsList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_RatingsStatusList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ratingsList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListRatingsRequest
- (id)init
{
	if((self = [super init])) {
		authToken = 0;
		ratingsList = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authToken != nil) [authToken release];
	if(ratingsList != nil) [ratingsList release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authToken != 0) {
		xmlAddChild(node, [self.authToken xmlNodeForDoc:node->doc elementName:@"authToken" elementNSPrefix:nil]);
	}
	if(self.ratingsList != 0) {
		xmlAddChild(node, [self.ratingsList xmlNodeForDoc:node->doc elementName:@"ratingsList" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authToken;
@synthesize ratingsList;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListRatingsRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListRatingsRequest *newObject = [[tns1_ListRatingsRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authToken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authToken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ratingsList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ListRatingsRequestList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ratingsList = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_ListRatingsResponse
- (id)init
{
	if((self = [super init])) {
		statusMessage = 0;
		ratingsList = 0;
		itemsCount = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusMessage != nil) [statusMessage release];
	if(ratingsList != nil) [ratingsList release];
	if(itemsCount != nil) [itemsCount release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusMessage != 0) {
		xmlAddChild(node, [self.statusMessage xmlNodeForDoc:node->doc elementName:@"statusMessage" elementNSPrefix:nil]);
	}
	if(self.ratingsList != 0) {
		xmlAddChild(node, [self.ratingsList xmlNodeForDoc:node->doc elementName:@"ratingsList" elementNSPrefix:nil]);
	}
	if(self.itemsCount != 0) {
		xmlAddChild(node, [self.itemsCount xmlNodeForDoc:node->doc elementName:@"itemsCount" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusMessage;
@synthesize ratingsList;
@synthesize itemsCount;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_ListRatingsResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_ListRatingsResponse *newObject = [[tns1_ListRatingsResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusMessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusMessage = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "ratingsList")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_RatingsStatusList class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.ratingsList = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "itemsCount")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_ItemsCount class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.itemsCount = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_DeregisterAllDevicesRequest
- (id)init
{
	if((self = [super init])) {
		authToken = 0;
		deregistrationConfirmed = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(authToken != nil) [authToken release];
	if(deregistrationConfirmed != nil) [deregistrationConfirmed release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.authToken != 0) {
		xmlAddChild(node, [self.authToken xmlNodeForDoc:node->doc elementName:@"authToken" elementNSPrefix:nil]);
	}
	if(self.deregistrationConfirmed != 0) {
		xmlAddChild(node, [self.deregistrationConfirmed xmlNodeForDoc:node->doc elementName:@"deregistrationConfirmed" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize authToken;
@synthesize deregistrationConfirmed;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_DeregisterAllDevicesRequest *)deserializeNode:(xmlNodePtr)cur
{
	tns1_DeregisterAllDevicesRequest *newObject = [[tns1_DeregisterAllDevicesRequest new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "authToken")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [NSString class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.authToken = newChild;
                }
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "deregistrationConfirmed")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [USBoolean class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.deregistrationConfirmed = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
@implementation tns1_DeregisterAllDevicesResponse
- (id)init
{
	if((self = [super init])) {
		statusMessage = 0;
	}
	
	return self;
}
- (void)dealloc
{
	if(statusMessage != nil) [statusMessage release];
	
	[super dealloc];
}
- (NSString *)nsPrefix
{
	return @"tns1";
}
- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = nil;
	if(elNSPrefix != nil && [elNSPrefix length] > 0)
	{
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];
	}
	else
	{
		nodeName = elName;
	}
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
	
	[self addAttributesToNode:node];
	
	[self addElementsToNode:node];
	
	return node;
}
- (void)addAttributesToNode:(xmlNodePtr)node
{
	
}
- (void)addElementsToNode:(xmlNodePtr)node
{
	
	if(self.statusMessage != 0) {
		xmlAddChild(node, [self.statusMessage xmlNodeForDoc:node->doc elementName:@"statusMessage" elementNSPrefix:nil]);
	}
}
/* elements */
@synthesize statusMessage;
/* attributes */
- (NSDictionary *)attributes
{
	NSMutableDictionary *attributes = [NSMutableDictionary dictionary];
	
	return attributes;
}
+ (tns1_DeregisterAllDevicesResponse *)deserializeNode:(xmlNodePtr)cur
{
	tns1_DeregisterAllDevicesResponse *newObject = [[tns1_DeregisterAllDevicesResponse new] autorelease];
	
	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}
- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
}
- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
	
	
	for( cur = cur->children ; cur != NULL ; cur = cur->next ) {
		if(cur->type == XML_ELEMENT_NODE) {
			xmlChar *elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString *elementString = nil;
			
			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char*)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
			if(xmlStrEqual(cur->name, (const xmlChar *) "statusMessage")) {
				BOOL nilProperty = NO;
                for(xmlAttrPtr attr = cur->properties; attr != NULL; attr = attr->next) {
                    if(xmlStrEqual(attr->name, (const xmlChar *) "nil") &&
                       attr->children &&
                       xmlStrEqual(attr->children->content, (const xmlChar *) "true"))
                        nilProperty = YES;
                        break;
                }
                if (nilProperty == NO) {				
                    Class elementClass = nil;
                    xmlChar *instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");
                    if(instanceType == NULL) {
                        elementClass = [tns1_StatusHolder class];
                    } else {
                        NSString *elementTypeString = [NSString stringWithCString:(char*)instanceType encoding:NSUTF8StringEncoding];
					
                        NSArray *elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
					
                        NSString *elementClassString = nil;
                        if([elementTypeArray count] > 1) {
                            NSString *prefix = [elementTypeArray objectAtIndex:0];
                            NSString *localName = [elementTypeArray objectAtIndex:1];
						
                            xmlNsPtr elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
						
                            NSString *standardPrefix = [[USGlobals sharedInstance].wsdlStandardNamespaces objectForKey:[NSString stringWithCString:(char*)elementNamespace->href encoding:NSUTF8StringEncoding]];
						
                            elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
                        } else {
                            elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_" options:0 range:NSMakeRange(0, [elementTypeString length])];
                        }
					
                        elementClass = NSClassFromString(elementClassString);
                        xmlFree(instanceType);
                    }
				
                    id newChild = [elementClass deserializeNode:cur];
				
                    self.statusMessage = newChild;
                }
			}
		}
	}
}
/* NSCoder functions taken from: 
 * http://davedelong.com/blog/2009/04/13/aspect-oriented-programming-objective-c
 */
- (id) initWithCoder:(NSCoder *)decoder {
	//if ([super respondsToSelector:@selector(initWithCoder:)] && ![self isKindOfClass:[super class]]) {
	//	self = [(id)super initWithCoder:decoder];
	//} else {
		self = [super init];
	//}
	if (self == nil) { return nil; }
 
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for(int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [decoder decodeObjectForKey:key];
		if (val == nil) { val = [NSNumber numberWithFloat:0.0]; }
		[self setValue:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
	return self;
}
- (void) encodeWithCoder:(NSCoder *)encoder {
	if ([super respondsToSelector:@selector(encodeWithCoder:)] && ![self isKindOfClass:[super class]]) {
		[super performSelector:@selector(encodeWithCoder:) withObject:encoder];
	}
	NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
	unsigned int numIvars = 0;
	Ivar * ivars = class_copyIvarList([self class], &numIvars);
	for (int i = 0; i < numIvars; i++) {
		Ivar thisIvar = ivars[i];
		NSString * key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];
		id val = [self valueForKey:key];
		[encoder encodeObject:val forKey:key];
	}
	if (numIvars > 0) { free(ivars); }
	[pool drain];
}
@end
